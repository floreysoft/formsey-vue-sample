/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 21);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ customElement; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ property; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ query; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ queryAll; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ eventOptions; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ lit_html["e" /* html */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ css; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ lit_element_LitElement; });

// UNUSED EXPORTS: defaultConverter, notEqual, UpdatingElement, internalProperty, queryAsync, queryAssignedNodes, svg, TemplateResult, SVGTemplateResult, supportsAdoptingStyleSheets, CSSResult, unsafeCSS

// EXTERNAL MODULE: ./node_modules/lit-html/lib/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/template.js
var lib_template = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/lit-html/lib/modify-template.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module shady-render
 */

const walkerNodeFilter = 133
/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
;
/**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */

function removeNodesFromTemplate(template, nodesToRemove) {
  const {
    element: {
      content
    },
    parts
  } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts);
  let part = parts[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;

  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode; // End removal if stepped past the removing node

    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    } // A node to remove was found in the template


    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node); // Track node we're removing

      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    } // When removing, increment count by which to adjust subsequent part indices


    if (currentRemovingNode !== null) {
      removeCount++;
    }

    while (part !== undefined && part.index === nodeIndex) {
      // If part is in a removed node deactivate it by setting index to -1 or
      // adjust the index as needed.
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.

      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
      part = parts[partIndex];
    }
  }

  nodesToRemoveInTemplate.forEach(n => n.parentNode.removeChild(n));
}

const countNodes = node => {
  let count = node.nodeType === 11
  /* Node.DOCUMENT_FRAGMENT_NODE */
  ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);

  while (walker.nextNode()) {
    count++;
  }

  return count;
};

const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
  for (let i = startIndex + 1; i < parts.length; i++) {
    const part = parts[i];

    if (Object(lib_template["d" /* isTemplatePartActive */])(part)) {
      return i;
    }
  }

  return -1;
};
/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */


function insertNodeIntoTemplate(template, node, refNode = null) {
  const {
    element: {
      content
    },
    parts
  } = template; // If there's no refNode, then put node at end of template.
  // No part indices need to be shifted in this case.

  if (refNode === null || refNode === undefined) {
    content.appendChild(node);
    return;
  }

  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts);
  let insertCount = 0;
  let walkerIndex = -1;

  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;

    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }

    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
      // If we've inserted the node, simply adjust all subsequent parts
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
        }

        return;
      }

      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
    }
  }
}
// EXTERNAL MODULE: ./node_modules/lit-html/lib/render.js
var render = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/template-factory.js
var template_factory = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/template-instance.js
var template_instance = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/lit-html/lit-html.js + 1 modules
var lit_html = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/lit-html/lib/shady-render.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Module to add shady DOM/shady CSS polyfill support to lit-html template
 * rendering. See the [[render]] method for details.
 *
 * @module shady-render
 * @preferred
 */

/**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */






 // Get a key to lookup in `templateCaches`.

const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;

let compatibleShadyCSSVersion = true;

if (typeof window.ShadyCSS === 'undefined') {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
  console.warn(`Incompatible ShadyCSS version detected. ` + `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` + `@webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */


const shadyTemplateFactory = scopeName => result => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = template_factory["a" /* templateCaches */].get(cacheKey);

  if (templateCache === undefined) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    template_factory["a" /* templateCaches */].set(cacheKey, templateCache);
  }

  let template = templateCache.stringsArray.get(result.strings);

  if (template !== undefined) {
    return template;
  }

  const key = result.strings.join(lib_template["f" /* marker */]);
  template = templateCache.keyString.get(key);

  if (template === undefined) {
    const element = result.getTemplateElement();

    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }

    template = new lib_template["a" /* Template */](result, element);
    templateCache.keyString.set(key, template);
  }

  templateCache.stringsArray.set(result.strings, template);
  return template;
};

const TEMPLATE_TYPES = ['html', 'svg'];
/**
 * Removes all style elements from Templates for the given scopeName.
 */

const removeStylesFromLitTemplates = scopeName => {
  TEMPLATE_TYPES.forEach(type => {
    const templates = template_factory["a" /* templateCaches */].get(getTemplateCacheKey(type, scopeName));

    if (templates !== undefined) {
      templates.keyString.forEach(template => {
        const {
          element: {
            content
          }
        } = template; // IE 11 doesn't support the iterable param Set constructor

        const styles = new Set();
        Array.from(content.querySelectorAll('style')).forEach(s => {
          styles.add(s);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};

const shadyRenderSet = new Set();
/**
 * For the given scope name, ensures that ShadyCSS style scoping is performed.
 * This is done just once per scope name so the fragment and template cannot
 * be modified.
 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
 * to be scoped and appended to the document
 * (2) removes style elements from all lit-html Templates for this scope name.
 *
 * Note, <style> elements can only be placed into templates for the
 * initial rendering of the scope. If <style> elements are included in templates
 * dynamically rendered to the scope (after the first scope render), they will
 * not be scoped and the <style> will be left in the template and rendered
 * output.
 */

const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName); // If `renderedDOM` is stamped from a Template, then we need to edit that
  // Template's underlying template element. Otherwise, we create one here
  // to give to ShadyCSS, which still requires one while scoping.

  const templateElement = !!template ? template.element : document.createElement('template'); // Move styles out of rendered DOM and store.

  const styles = renderedDOM.querySelectorAll('style');
  const {
    length
  } = styles; // If there are no styles, skip unnecessary work

  if (length === 0) {
    // Ensure prepareTemplateStyles is called to support adding
    // styles via `prepareAdoptedCssText` since that requires that
    // `prepareTemplateStyles` is called.
    //
    // ShadyCSS will only update styles containing @apply in the template
    // given to `prepareTemplateStyles`. If no lit Template was given,
    // ShadyCSS will not be able to update uses of @apply in any relevant
    // template. However, this is not a problem because we only create the
    // template for the purpose of supporting `prepareAdoptedCssText`,
    // which doesn't support @apply at all.
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }

  const condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS
  // manipulations will not prevent us from being able to fix up template
  // part indices.
  // NOTE: collecting styles is inefficient for browsers but ShadyCSS
  // currently does this anyway. When it does not, this should be changed.

  for (let i = 0; i < length; i++) {
    const style = styles[i];
    style.parentNode.removeChild(style);
    condensedStyle.textContent += style.textContent;
  } // Remove styles from nested templates in this scope.


  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the "root" template passed in as
  // `template`.

  const content = templateElement.content;

  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  } // Note, it's important that ShadyCSS gets the template that `lit-html`
  // will actually render so that it can update the style inside when
  // needed (e.g. @apply native Shadow DOM case).


  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content.querySelector('style');

  if (window.ShadyCSS.nativeShadow && style !== null) {
    // When in native Shadow DOM, ensure the style created by ShadyCSS is
    // included in initially rendered output (`renderedDOM`).
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    // When no style is left in the template, parts will be broken as a
    // result. To fix this, we put back the style node ShadyCSS removed
    // and then tell lit to remove that node from the template.
    // There can be no style in the template in 2 cases (1) when Shady DOM
    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
    // is in use ShadyCSS removes the style if it contains no content.
    // NOTE, ShadyCSS creates its own style so we can safely add/remove
    // `condensedStyle` here.
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
/**
 * Extension to the standard `render` method which supports rendering
 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
 * or when the webcomponentsjs
 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
 *
 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
 * when native ShadowDOM is unavailable. The `scopeName` will be added to
 * the class attribute of all rendered DOM. In addition, any style elements will
 * be automatically re-written with this `scopeName` selector and moved out
 * of the rendered DOM and into the document `<head>`.
 *
 * It is common to use this render method in conjunction with a custom element
 * which renders a shadowRoot. When this is done, typically the element's
 * `localName` should be used as the `scopeName`.
 *
 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
 * custom properties (needed only on older browsers like IE11) and a shim for
 * a deprecated feature called `@apply` that supports applying a set of css
 * custom properties to a given location.
 *
 * Usage considerations:
 *
 * * Part values in `<style>` elements are only applied the first time a given
 * `scopeName` renders. Subsequent changes to parts in style elements will have
 * no effect. Because of this, parts in style elements should only be used for
 * values that will never change, for example parts that set scope-wide theme
 * values or parts which render shared style elements.
 *
 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
 * custom element's `constructor` is not supported. Instead rendering should
 * either done asynchronously, for example at microtask timing (for example
 * `Promise.resolve()`), or be deferred until the first time the element's
 * `connectedCallback` runs.
 *
 * Usage considerations when using shimmed custom properties or `@apply`:
 *
 * * Whenever any dynamic changes are made which affect
 * css custom properties, `ShadyCSS.styleElement(element)` must be called
 * to update the element. There are two cases when this is needed:
 * (1) the element is connected to a new parent, (2) a class is added to the
 * element that causes it to match different custom properties.
 * To address the first case when rendering a custom element, `styleElement`
 * should be called in the element's `connectedCallback`.
 *
 * * Shimmed custom properties may only be defined either for an entire
 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
 * matches an element with a shadowRoot. In other words, instead of flowing from
 * parent to child as do native css custom properties, shimmed custom properties
 * flow only from shadowRoots to nested shadowRoots.
 *
 * * When using `@apply` mixing css shorthand property names with
 * non-shorthand names (for example `border` and `border-width`) is not
 * supported.
 */


const shady_render_render = (result, container, options) => {
  if (!options || typeof options !== 'object' || !options.scopeName) {
    throw new Error('The `scopeName` option is required.');
  }

  const scopeName = options.scopeName;
  const hasRendered = render["a" /* parts */].has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11
  /* Node.DOCUMENT_FRAGMENT_NODE */
  && !!container.host; // Handle first render to a scope specially...

  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single
  // fragment that is reused since nested renders can occur synchronously.

  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  Object(render["b" /* render */])(result, renderContainer, Object.assign({
    templateFactory: shadyTemplateFactory(scopeName)
  }, options)); // When performing first scope render,
  // (1) We've rendered into a fragment so that there's a chance to
  // `prepareTemplateStyles` before sub-elements hit the DOM
  // (which might cause them to render based on a common pattern of
  // rendering in a custom element's `connectedCallback`);
  // (2) Scope the template with ShadyCSS one time only for this scope.
  // (3) Render the fragment into the container and make sure the
  // container knows its `part` is the one we just rendered. This ensures
  // DOM will be re-used on subsequent renders.

  if (firstScopeRender) {
    const part = render["a" /* parts */].get(renderContainer);
    render["a" /* parts */].delete(renderContainer); // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
    // that should apply to `renderContainer` even if the rendered value is
    // not a TemplateInstance. However, it will only insert scoped styles
    // into the document if `prepareTemplateStyles` has already been called
    // for the given scope name.

    const template = part.value instanceof template_instance["a" /* TemplateInstance */] ? part.value.template : undefined;
    prepareTemplateStyles(scopeName, renderContainer, template);
    Object(dom["b" /* removeNodes */])(container, container.firstChild);
    container.appendChild(renderContainer);
    render["a" /* parts */].set(container, part);
  } // After elements have hit the DOM, update styling if this is the
  // initial render to this container.
  // This is needed whenever dynamic changes are made so it would be
  // safest to do every render; however, this would regress performance
  // so we leave it up to the user to call `ShadyCSS.styleElement`
  // for dynamic changes.


  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};
// CONCATENATED MODULE: ./node_modules/lit-element/lib/updating-element.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var _a;
/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */


window.JSCompiler_renameProperty = (prop, _obj) => prop;

const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? '' : null;

      case Object:
      case Array:
        // if the value is `null` or `undefined` pass this through
        // to allow removing/no change behavior.
        return value == null ? value : JSON.stringify(value);
    }

    return value;
  },

  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;

      case Number:
        return value === null ? null : Number(value);

      case Object:
      case Array:
        return JSON.parse(value);
    }

    return value;
  }

};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */

const notEqual = (value, old) => {
  // This ensures (old==NaN, value==NaN) always returns false
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
/**
 * The Closure JS Compiler doesn't currently have good support for static
 * property semantics where "this" is dynamic (e.g.
 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
 * this hack to bypass any rewriting by the compiler.
 */

const finalized = 'finalized';
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */

class UpdatingElement extends HTMLElement {
  constructor() {
    super();
    this._updateState = 0;
    this._instanceProperties = undefined; // Initialize to an unresolved Promise so we can make sure the element has
    // connected before first update.

    this._updatePromise = new Promise(res => this._enableUpdatingResolver = res);
    /**
     * Map with keys for any properties that have changed since the last
     * update cycle with previous values.
     */

    this._changedProperties = new Map();
    /**
     * Map with keys of properties that should be reflected when updated.
     */

    this._reflectingProperties = undefined;
    this.initialize();
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   */


  static get observedAttributes() {
    // note: piggy backing on this to ensure we're finalized.
    this.finalize();
    const attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays

    this._classProperties.forEach((v, p) => {
      const attr = this._attributeNameForProperty(p, v);

      if (attr !== undefined) {
        this._attributeToPropertyMap.set(attr, p);

        attributes.push(attr);
      }
    });

    return attributes;
  }
  /**
   * Ensures the private `_classProperties` property metadata is created.
   * In addition to `finalize` this is also called in `createProperty` to
   * ensure the `@property` decorator can add property metadata.
   */

  /** @nocollapse */


  static _ensureClassProperties() {
    // ensure private storage for property declarations.
    if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
      this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.

      const superProperties = Object.getPrototypeOf(this)._classProperties;

      if (superProperties !== undefined) {
        superProperties.forEach((v, k) => this._classProperties.set(k, v));
      }
    }
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a PropertyDeclaration for the property with the given options.
   * The property setter calls the property's `hasChanged` property option
   * or uses a strict identity check to determine whether or not to request
   * an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   *
   * @nocollapse
   */


  static createProperty(name, options = defaultPropertyDeclaration) {
    // Note, since this can be called by the `@property` decorator which
    // is called before `finalize`, we ensure storage exists for property
    // metadata.
    this._ensureClassProperties();

    this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since
    // it would be lost otherwise and that would never be the user's intention;
    // Instead, we expect users to call `requestUpdate` themselves from
    // user-defined accessors. Note that if the super has an accessor we will
    // still overwrite it


    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }

    const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options);

    if (descriptor !== undefined) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   *   class MyElement extends LitElement {
   *     static getPropertyDescriptor(name, key, options) {
   *       const defaultDescriptor =
   *           super.getPropertyDescriptor(name, key, options);
   *       const setter = defaultDescriptor.set;
   *       return {
   *         get: defaultDescriptor.get,
   *         set(value) {
   *           setter.call(this, value);
   *           // custom action.
   *         },
   *         configurable: true,
   *         enumerable: true
   *       }
   *     }
   *   }
   *
   * @nocollapse
   */


  static getPropertyDescriptor(name, key, _options) {
    return {
      // tslint:disable-next-line:no-any no symbol in index
      get() {
        return this[key];
      },

      set(value) {
        const oldValue = this[name];
        this[key] = value;

        this._requestUpdate(name, oldValue);
      },

      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a PropertyDeclaration via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override `createProperty`.
   *
   * @nocollapse
   * @final
   */


  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  /**
   * Creates property accessors for registered properties and ensures
   * any superclasses are also finalized.
   * @nocollapse
   */


  static finalize() {
    // finalize any superclasses
    const superCtor = Object.getPrototypeOf(this);

    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }

    this[finalized] = true;

    this._ensureClassProperties(); // initialize Map populated in observedAttributes


    this._attributeToPropertyMap = new Map(); // make any properties
    // Note, only process "own" properties since this element will inherit
    // any properties defined on the superClass, and finalization ensures
    // the entire prototype chain is finalized.

    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
      const props = this.properties; // support symbols in properties (IE11 does not support this)

      const propKeys = [...Object.getOwnPropertyNames(props), ...(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])]; // This for/of is ok because propKeys is an array

      for (const p of propKeys) {
        // note, use of `any` is due to TypeSript lack of support for symbol in
        // index types
        // tslint:disable-next-line:no-any no symbol in index
        this.createProperty(p, props[p]);
      }
    }
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */


  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;
  }
  /**
   * Returns true if a property should request an update.
   * Called when a property value is set and uses the `hasChanged`
   * option for the property if present or a strict identity check.
   * @nocollapse
   */


  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  /**
   * Returns the property value for the given attribute value.
   * Called via the `attributeChangedCallback` and uses the property's
   * `converter` or `converter.fromAttribute` property option.
   * @nocollapse
   */


  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  /**
   * Returns the attribute value for the given property value. If this
   * returns undefined, the property will *not* be reflected to an attribute.
   * If this returns null, the attribute will be removed, otherwise the
   * attribute will be set to the value.
   * This uses the property's `reflect` and `type.toAttribute` property options.
   * @nocollapse
   */


  static _propertyValueToAttribute(value, options) {
    if (options.reflect === undefined) {
      return;
    }

    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  /**
   * Performs element initialization. By default captures any pre-set values for
   * registered properties.
   */


  initialize() {
    this._saveInstanceProperties(); // ensures first update will be caught by an early access of
    // `updateComplete`


    this._requestUpdate();
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */


  _saveInstanceProperties() {
    // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays
    this.constructor._classProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        const value = this[p];
        delete this[p];

        if (!this._instanceProperties) {
          this._instanceProperties = new Map();
        }

        this._instanceProperties.set(p, value);
      }
    });
  }
  /**
   * Applies previously saved instance properties.
   */


  _applyInstanceProperties() {
    // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays
    // tslint:disable-next-line:no-any
    this._instanceProperties.forEach((v, p) => this[p] = v);

    this._instanceProperties = undefined;
  }

  connectedCallback() {
    // Ensure first connection completes an update. Updates cannot complete
    // before connection.
    this.enableUpdating();
  }

  enableUpdating() {
    if (this._enableUpdatingResolver !== undefined) {
      this._enableUpdatingResolver();

      this._enableUpdatingResolver = undefined;
    }
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   */


  disconnectedCallback() {}
  /**
   * Synchronizes property values when attributes change.
   */


  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }

  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;

    const attr = ctor._attributeNameForProperty(name, options);

    if (attr !== undefined) {
      const attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.


      if (attrValue === undefined) {
        return;
      } // Track if the property is being reflected to avoid
      // setting the property again via `attributeChangedCallback`. Note:
      // 1. this takes advantage of the fact that the callback is synchronous.
      // 2. will behave incorrectly if multiple attributes are in the reaction
      // stack at time of calling. However, since we process attributes
      // in `update` this should not be possible (or an extreme corner case
      // that we'd like to discover).
      // mark state reflecting


      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;

      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      } // mark state not reflecting


      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }

  _attributeToProperty(name, value) {
    // Use tracking info to avoid deserializing attribute value if it was
    // just set from a property setter.
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }

    const ctor = this.constructor; // Note, hint this as an `AttributeMap` so closure clearly understands
    // the type; it has issues with tracking types through statics
    // tslint:disable-next-line:no-unnecessary-type-assertion

    const propName = ctor._attributeToPropertyMap.get(name);

    if (propName !== undefined) {
      const options = ctor.getPropertyOptions(propName); // mark state reflecting

      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = // tslint:disable-next-line:no-any
      ctor._propertyValueFromAttribute(value, options); // mark state not reflecting

      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  /**
   * This private version of `requestUpdate` does not access or return the
   * `updateComplete` promise. This promise can be overridden and is therefore
   * not free to access.
   */


  _requestUpdate(name, oldValue) {
    let shouldRequestUpdate = true; // If we have a property key, perform property update steps.

    if (name !== undefined) {
      const ctor = this.constructor;
      const options = ctor.getPropertyOptions(name);

      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        } // Add to reflecting properties set.
        // Note, it's important that every change has a chance to add the
        // property to `_reflectingProperties`. This ensures setting
        // attribute + property reflects correctly.


        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === undefined) {
            this._reflectingProperties = new Map();
          }

          this._reflectingProperties.set(name, options);
        }
      } else {
        // Abort the request if the property should not be considered changed.
        shouldRequestUpdate = false;
      }
    }

    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should
   * be called when an element should update based on some state not triggered
   * by setting a property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored. Returns the `updateComplete` Promise which is resolved
   * when the update completes.
   *
   * @param name {PropertyKey} (optional) name of requesting property
   * @param oldValue {any} (optional) old value of requesting property
   * @returns {Promise} A Promise that is resolved when the update completes.
   */


  requestUpdate(name, oldValue) {
    this._requestUpdate(name, oldValue);

    return this.updateComplete;
  }
  /**
   * Sets up the element to asynchronously update.
   */


  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;

    try {
      // Ensure any previous update has resolved before updating.
      // This `await` also ensures that property changes are batched.
      await this._updatePromise;
    } catch (e) {// Ignore any previous errors. We only care that the previous cycle is
      // done. Any error should have been handled in the previous update.
    }

    const result = this.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to
    // enable coordinating updates with a scheduler. Note, the result is
    // checked to avoid delaying an additional microtask unless we need to.

    if (result != null) {
      await result;
    }

    return !this._hasRequestedUpdate;
  }

  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }

  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * You can override this method to change the timing of updates. If this
   * method is overridden, `super.performUpdate()` must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```
   * protected async performUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.performUpdate();
   * }
   * ```
   */


  performUpdate() {
    // Mixin instance properties once, if they exist.
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }

    let shouldUpdate = false;
    const changedProperties = this._changedProperties;

    try {
      shouldUpdate = this.shouldUpdate(changedProperties);

      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e) {
      // Prevent `firstUpdated` and `updated` from running when there's an
      // update exception.
      shouldUpdate = false; // Ensure element can accept additional updates after an exception.

      this._markUpdated();

      throw e;
    }

    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }

      this.updated(changedProperties);
    }
  }

  _markUpdated() {
    this._changedProperties = new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `_getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super._getUpdateComplete()`, then any subsequent state.
   *
   * @returns {Promise} The Promise returns a boolean that indicates if the
   * update resolved without triggering another update.
   */


  get updateComplete() {
    return this._getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async _getUpdateComplete() {
   *       await super._getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   */


  _getUpdateComplete() {
    return this._updatePromise;
  }
  /**
   * Controls whether or not `update` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   */


  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   */


  update(_changedProperties) {
    if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {
      // Use forEach so this works even if for/of loops are compiled to for
      // loops expecting arrays
      this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));

      this._reflectingProperties = undefined;
    }

    this._markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */


  updated(_changedProperties) {}
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */


  firstUpdated(_changedProperties) {}

}
_a = finalized;
/**
 * Marks class as having finished creating properties.
 */

UpdatingElement[_a] = true;
// CONCATENATED MODULE: ./node_modules/lit-element/lib/decorators.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const legacyCustomElement = (tagName, clazz) => {
  window.customElements.define(tagName, clazz); // Cast as any because TS doesn't recognize the return type as being a
  // subtype of the decorated class when clazz is typed as
  // `Constructor<HTMLElement>` for some reason.
  // `Constructor<HTMLElement>` is helpful to make sure the decorator is
  // applied to elements however.
  // tslint:disable-next-line:no-any

  return clazz;
};

const standardCustomElement = (tagName, descriptor) => {
  const {
    kind,
    elements
  } = descriptor;
  return {
    kind,
    elements,

    // This callback is called once the class is otherwise fully defined
    finisher(clazz) {
      window.customElements.define(tagName, clazz);
    }

  };
};
/**
 * Class decorator factory that defines the decorated class as a custom element.
 *
 * ```
 * @customElement('my-element')
 * class MyElement {
 *   render() {
 *     return html``;
 *   }
 * }
 * ```
 *
 * @param tagName The name of the custom element to define.
 */


const customElement = tagName => classOrDescriptor => typeof classOrDescriptor === 'function' ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);

const standardProperty = (options, element) => {
  // When decorating an accessor, pass it through and add property metadata.
  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
  // stomp over the user's accessor.
  if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
    return Object.assign(Object.assign({}, element), {
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }

    });
  } else {
    // createProperty() takes care of defining the property, but we still
    // must return some kind of descriptor, so return a descriptor for an
    // unused prototype field. The finisher calls createProperty().
    return {
      kind: 'field',
      key: Symbol(),
      placement: 'own',
      descriptor: {},

      // When @babel/plugin-proposal-decorators implements initializers,
      // do this instead of the initializer below. See:
      // https://github.com/babel/babel/issues/9260 extras: [
      //   {
      //     kind: 'initializer',
      //     placement: 'own',
      //     initializer: descriptor.initializer,
      //   }
      // ],
      initializer() {
        if (typeof element.initializer === 'function') {
          this[element.key] = element.initializer.call(this);
        }
      },

      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }

    };
  }
};

const legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};
/**
 * A property decorator which creates a LitElement property which reflects a
 * corresponding attribute value. A `PropertyDeclaration` may optionally be
 * supplied to configure property features.
 *
 * This decorator should only be used for public fields. Private or protected
 * fields should use the internalProperty decorator.
 *
 * @example
 *
 *     class MyElement {
 *       @property({ type: Boolean })
 *       clicked = false;
 *     }
 *
 * @ExportDecoratedItems
 */


function property(options) {
  // tslint:disable-next-line:no-any decorator
  return (protoOrDescriptor, name) => name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}
/**
 * Declares a private or protected property that still triggers updates to the
 * element when it changes.
 *
 * Properties declared this way must not be used from HTML or HTML templating
 * systems, they're solely for properties internal to the element. These
 * properties may be renamed by optimization tools like closure compiler.
 */

function internalProperty(options) {
  return property({
    attribute: false,
    hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged
  });
}
/**
 * A property decorator that converts a class property into a getter that
 * executes a querySelector on the element's renderRoot.
 *
 * @param selector A DOMString containing one or more selectors to match.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
 *
 * @example
 *
 *     class MyElement {
 *       @query('#first')
 *       first;
 *
 *       render() {
 *         return html`
 *           <div id="first"></div>
 *           <div id="second"></div>
 *         `;
 *       }
 *     }
 *
 */

function query(selector) {
  return (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
  name) => {
    const descriptor = {
      get() {
        return this.renderRoot.querySelector(selector);
      },

      enumerable: true,
      configurable: true
    };
    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
} // Note, in the future, we may extend this decorator to support the use case
// where the queried element may need to do work to become ready to interact
// with (e.g. load some implementation code). If so, we might elect to
// add a second argument defining a function that can be run to make the
// queried element loaded/updated/ready.

/**
 * A property decorator that converts a class property into a getter that
 * returns a promise that resolves to the result of a querySelector on the
 * element's renderRoot done after the element's `updateComplete` promise
 * resolves. When the queried property may change with element state, this
 * decorator can be used instead of requiring users to await the
 * `updateComplete` before accessing the property.
 *
 * @param selector A DOMString containing one or more selectors to match.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
 *
 * @example
 *
 *     class MyElement {
 *       @queryAsync('#first')
 *       first;
 *
 *       render() {
 *         return html`
 *           <div id="first"></div>
 *           <div id="second"></div>
 *         `;
 *       }
 *     }
 *
 *     // external usage
 *     async doSomethingWithFirst() {
 *      (await aMyElement.first).doSomething();
 *     }
 */

function queryAsync(selector) {
  return (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
  name) => {
    const descriptor = {
      async get() {
        await this.updateComplete;
        return this.renderRoot.querySelector(selector);
      },

      enumerable: true,
      configurable: true
    };
    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}
/**
 * A property decorator that converts a class property into a getter
 * that executes a querySelectorAll on the element's renderRoot.
 *
 * @param selector A DOMString containing one or more selectors to match.
 *
 * See:
 * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll
 *
 * @example
 *
 *     class MyElement {
 *       @queryAll('div')
 *       divs;
 *
 *       render() {
 *         return html`
 *           <div id="first"></div>
 *           <div id="second"></div>
 *         `;
 *       }
 *     }
 */

function queryAll(selector) {
  return (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
  name) => {
    const descriptor = {
      get() {
        return this.renderRoot.querySelectorAll(selector);
      },

      enumerable: true,
      configurable: true
    };
    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}

const legacyQuery = (descriptor, proto, name) => {
  Object.defineProperty(proto, name, descriptor);
};

const standardQuery = (descriptor, element) => ({
  kind: 'method',
  placement: 'prototype',
  key: element.key,
  descriptor
});

const standardEventOptions = (options, element) => {
  return Object.assign(Object.assign({}, element), {
    finisher(clazz) {
      Object.assign(clazz.prototype[element.key], options);
    }

  });
};

const legacyEventOptions = // tslint:disable-next-line:no-any legacy decorator
(options, proto, name) => {
  Object.assign(proto[name], options);
};
/**
 * Adds event listener options to a method used as an event listener in a
 * lit-html template.
 *
 * @param options An object that specifies event listener options as accepted by
 * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.
 *
 * Current browsers support the `capture`, `passive`, and `once` options. See:
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters
 *
 * @example
 *
 *     class MyElement {
 *       clicked = false;
 *
 *       render() {
 *         return html`
 *           <div @click=${this._onClick}`>
 *             <button></button>
 *           </div>
 *         `;
 *       }
 *
 *       @eventOptions({capture: true})
 *       _onClick(e) {
 *         this.clicked = true;
 *       }
 *     }
 */


function eventOptions(options) {
  // Return value typed as any to prevent TypeScript from complaining that
  // standard decorator function signature does not match TypeScript decorator
  // signature
  // TODO(kschaaf): unclear why it was only failing on this decorator and not
  // the others
  return (protoOrDescriptor, name) => name !== undefined ? legacyEventOptions(options, protoOrDescriptor, name) : standardEventOptions(options, protoOrDescriptor);
}
/**
 * A property decorator that converts a class property into a getter that
 * returns the `assignedNodes` of the given named `slot`. Note, the type of
 * this property should be annotated as `NodeListOf<HTMLElement>`.
 *
 */

function queryAssignedNodes(slotName = '', flatten = false) {
  return (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
  name) => {
    const descriptor = {
      get() {
        const selector = `slot${slotName ? `[name=${slotName}]` : ''}`;
        const slot = this.renderRoot.querySelector(selector);
        return slot && slot.assignedNodes({
          flatten
        });
      },

      enumerable: true,
      configurable: true
    };
    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}
// CONCATENATED MODULE: ./node_modules/lit-element/lib/css-tag.js
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;
const constructionToken = Symbol();
class CSSResult {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
    }

    this.cssText = cssText;
  } // Note, this is a getter so that it's lazy. In practice, this means
  // stylesheets are not created until the first element instance is made.


  get styleSheet() {
    if (this._styleSheet === undefined) {
      // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet
      // is constructable.
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();

        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }

    return this._styleSheet;
  }

  toString() {
    return this.cssText;
  }

}
/**
 * Wrap a value for interpolation in a css tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */

const unsafeCSS = value => {
  return new CSSResult(String(value), constructionToken);
};

const textFromCSSResult = value => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === 'number') {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
/**
 * Template tag which which can be used with LitElement's `style` property to
 * set element styles. For security reasons, only literal string values may be
 * used. To incorporate non-literal values `unsafeCSS` may be used inside a
 * template string part.
 */


const css = (strings, ...values) => {
  const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};
// CONCATENATED MODULE: ./node_modules/lit-element/lit-element.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






 // IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for LitElement usage.
// TODO(justinfagnani): inject version number at build time

(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.3.1');
/**
 * Sentinal value used to avoid calling lit-html's render function when
 * subclasses do not implement `render`
 */

const renderNotImplemented = {};
class lit_element_LitElement extends UpdatingElement {
  /**
   * Return the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * @nocollapse
   */
  static getStyles() {
    return this.styles;
  }
  /** @nocollapse */


  static _getUniqueStyles() {
    // Only gather styles once per class
    if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
      return;
    } // Take care not to call `this.getStyles()` multiple times since this
    // generates new CSSResults each time.
    // TODO(sorvell): Since we do not cache CSSResults by input, any
    // shared styles will generate new stylesheet objects, which is wasteful.
    // This should be addressed when a browser ships constructable
    // stylesheets.


    const userStyles = this.getStyles();

    if (userStyles === undefined) {
      this._styles = [];
    } else if (Array.isArray(userStyles)) {
      // De-duplicate styles preserving the _last_ instance in the set.
      // This is a performance optimization to avoid duplicated styles that can
      // occur especially when composing via subclassing.
      // The last item is kept to try to preserve the cascade order with the
      // assumption that it's most important that last added styles override
      // previous styles.
      const addStyles = (styles, set) => styles.reduceRight((set, s) => // Note: On IE set.add() does not return the set
      Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set); // Array.from does not work on Set in IE, otherwise return
      // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()


      const set = addStyles(userStyles, new Set());
      const styles = [];
      set.forEach(v => styles.unshift(v));
      this._styles = styles;
    } else {
      this._styles = [userStyles];
    }
  }
  /**
   * Performs element initialization. By default this calls `createRenderRoot`
   * to create the element `renderRoot` node and captures any pre-set values for
   * registered properties.
   */


  initialize() {
    super.initialize();

    this.constructor._getUniqueStyles();

    this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
    // element's getRootNode(). While this could be done, we're choosing not to
    // support this now since it would require different logic around de-duping.

    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   * @returns {Element|DocumentFragment} Returns a node into which to render.
   */


  createRenderRoot() {
    return this.attachShadow({
      mode: 'open'
    });
  }
  /**
   * Applies styling to the element shadowRoot using the `static get styles`
   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
   * available and will fallback otherwise. When Shadow DOM is polyfilled,
   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
   * is available but `adoptedStyleSheets` is not, styles are appended to the
   * end of the `shadowRoot` to [mimic spec
   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
   */


  adoptStyles() {
    const styles = this.constructor._styles;

    if (styles.length === 0) {
      return;
    } // There are three separate cases here based on Shadow DOM support.
    // (1) shadowRoot polyfilled: use ShadyCSS
    // (2) shadowRoot.adoptedStyleSheets available: use it.
    // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
    // rendering


    if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(s => s.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map(s => s.styleSheet);
    } else {
      // This must be done after rendering so the actual style insertion is done
      // in `update`.
      this._needsShimAdoptedStyleSheets = true;
    }
  }

  connectedCallback() {
    super.connectedCallback(); // Note, first update/render handles styleElement so we only call this if
    // connected after first update.

    if (this.hasUpdated && window.ShadyCSS !== undefined) {
      window.ShadyCSS.styleElement(this);
    }
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param _changedProperties Map of changed properties with old values
   */


  update(changedProperties) {
    // Setting properties in `render` should not trigger an update. Since
    // updates are allowed after super.update, it's important to call `render`
    // before that.
    const templateResult = this.render();
    super.update(changedProperties); // If render is not implemented by the component, don't call lit-html render

    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, {
        scopeName: this.localName,
        eventContext: this
      });
    } // When native Shadow DOM is used but adoptedStyles are not supported,
    // insert styling after rendering to ensure adoptedStyles have highest
    // priority.


    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;

      this.constructor._styles.forEach(s => {
        const style = document.createElement('style');
        style.textContent = s.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's NodePart - typically a TemplateResult.
   * Setting properties inside this method will *not* trigger the element to
   * update.
   */


  render() {
    return renderNotImplemented;
  }

}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 *
 * Note this property name is a string to prevent breaking Closure JS Compiler
 * optimizations. See updating-element.ts for more information.
 */

lit_element_LitElement['finalized'] = true;
/**
 * Render method used to render the value to the element's DOM.
 * @param result The value to render.
 * @param container Node into which to render.
 * @param options Element name.
 * @nocollapse
 */

lit_element_LitElement.render = shady_render_render;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ ChangeEvent; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ createField; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ Field_Field; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ FormField_FormField; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ LabeledField_LabeledField; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ getTheme; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ getDefaultTheme; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ register; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ formsey_core_area; });

// UNUSED EXPORTS: BlurEvent, ClickEvent, CompoundField, Option, Image, Selection, FocusEvent, Form, NestedFormField, getThemes, registerTheme, applyMixins

// CONCATENATED MODULE: ./packages/formsey-core/BlurEvent.ts
class BlurEvent extends CustomEvent {
  constructor(name) {
    super("blur", {
      bubbles: true,
      composed: true,
      detail: {
        name
      }
    });
  }

}
// CONCATENATED MODULE: ./packages/formsey-core/ChangeEvent.ts
class ChangeEvent extends CustomEvent {
  constructor(type, name, value) {
    super(type, {
      bubbles: false,
      detail: {
        name,
        value
      }
    });
  }

}
// CONCATENATED MODULE: ./packages/formsey-core/ClickEvent.ts
class ClickEvent extends CustomEvent {
  constructor(name) {
    super("click", {
      bubbles: true,
      composed: true,
      detail: {
        name
      }
    });
  }

}
// EXTERNAL MODULE: ./node_modules/lit-element/lit-element.js + 5 modules
var lit_element = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/formsey-core/Field.ts
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





function hacktml(parts, ...args) {
  const newArgs = args.concat().slice(1, -1);
  const newParts = parts.concat().slice(1, -1);
  newParts[0] = "<" + args[0] + newParts[0];
  newParts[newParts.length - 1] = newParts[newParts.length - 1] + args[0] + ">";
  return Object(lit_element["e" /* html */])(newParts, ...newArgs);
}
const createField = (components, definition, value, parentPath, errors, changeHandler, invalidHandler) => {
  const component = components[definition.type];

  if (component) {
    return hacktml`<${component.tag} .components=${components} .definition=${definition} .value=${value} .parentPath=${parentPath} .errors=${errors} @change="${changeHandler}" @input="${changeHandler}" @invalid=${invalidHandler}></${component.tag}>`;
  } else {
    console.error("Your form is using a field of type=" + definition.type + " but no matching component has been registered!");
  }

  return lit_element["e" /* html */]``;
};
class Field_Field extends lit_element["a" /* LitElement */] {
  constructor() {
    super(...arguments);
    this.valid = true;
    this.report = false;
    this._errors = {};
  }

  set theme(theme) {
    let registeredTheme = getTheme(theme);

    if (registeredTheme) {
      this.components = registeredTheme.components;
    } else {
      let defaultTheme = getDefaultTheme();

      if (defaultTheme) {
        console.warn("Theme '" + theme + "' not availble, using '" + defaultTheme + "' instead");
        this.components = getTheme[defaultTheme].components;
      } else {
        console.error("Theme '" + theme + "' not availble, no theme installed!");
      }
    }
  }

  set errors(errors) {
    this.error = undefined;

    if (errors && this.definition.name) {
      this.error = errors[this.definition.name];
    }

    this._errors = errors;
    this.requestUpdate();
  }

  get errors() {
    return this._errors;
  }

  setCustomValidity(customErrors) {
    if (customErrors) {
      Object.keys(customErrors.errors).forEach(key => {
        customErrors.errors[key].custom = true;
      });
    }

    this.errors = customErrors;
  }

  reportValidity() {
    this.clearErrors();
    this.report = true;
    this.valid = this.validate(true);

    if (this.valid && this.error) {
      this.valid = false;
    }

    return this.valid;
  }

  checkValidity() {
    this.clearErrors();
    this.report = false;
    this.valid = this.validate(false);

    if (this.valid && this.error) {
      this.valid = false;
    }

    return this.valid;
  }

  validate(report) {
    return true;
  }

  static get styles() {
    return [lit_element["b" /* css */]`
    .hidden {
      display: none;
    }`];
  }

  createRenderRoot() {
    return this;
  }

  shouldUpdate() {
    if (typeof this.definition === "undefined") {
      return false;
    } else if (typeof this.value === "undefined" && typeof this.definition.default != "undefined") {
      this.value = this.definition.default;

      if (this.value && this.definition.name) {
        this.dispatchEvent(new ChangeEvent("change", this.definition.name, this.value));
      }
    }

    if (this.definition.hidden) {
      return false;
    }

    if (!this.components) {
      let defaultTheme = getDefaultTheme();

      if (typeof defaultTheme != "undefined") {
        this.components = getTheme(defaultTheme).components;
      }

      return typeof this.components != "undefined";
    }

    return true;
  }

  changed(e) {
    this.value = e.currentTarget.value;
    this.dispatchEvent(new ChangeEvent("change", this.definition.name, this.value));
  }

  inputted(e) {
    e.stopPropagation();
    this.value = e.currentTarget.value;
    this.dispatchEvent(new ChangeEvent("input", this.definition.name, this.value));
  }

  clicked(e) {
    e.stopPropagation();
    e.preventDefault();
    this.dispatchEvent(new ClickEvent(this.path()));
  }

  focused(e) {
    e.stopPropagation();
    e.preventDefault();
    this.dispatchEvent(new ClickEvent(this.path()));
  }

  blurred(e) {
    e.stopPropagation();
    e.preventDefault();
    this.dispatchEvent(new ClickEvent(this.path()));
  }

  firstPathElement(path) {
    return path.split('.')[0];
  }

  prependPath(path) {
    return (this.definition.name ? this.definition.name : "") + "." + path;
  }

  path() {
    return this.definition.name ? this.parentPath ? this.parentPath + "." + this.definition.name : this.definition.name : this.parentPath;
  }

  clearErrors() {
    // Keep custom errors
    if (this.errors) {
      for (let key in this.errors) {
        let error = this.errors[key];

        if (!error.custom) {
          delete this.errors[key];
        }
      }
    } else {
      this.errors = {};
    }

    if (this.error && !this.error.custom) {
      this.error = undefined;
    }
  }

}

__decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], Field_Field.prototype, "components", void 0);

__decorate([Object(lit_element["f" /* property */])({
  type: Object
})], Field_Field.prototype, "definition", void 0);

__decorate([Object(lit_element["f" /* property */])({
  type: Object
})], Field_Field.prototype, "value", void 0);

__decorate([Object(lit_element["f" /* property */])()], Field_Field.prototype, "parentPath", void 0);

__decorate([Object(lit_element["f" /* property */])({
  type: String
})], Field_Field.prototype, "theme", null);

__decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], Field_Field.prototype, "valid", void 0);

__decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], Field_Field.prototype, "report", void 0);

__decorate([Object(lit_element["f" /* property */])({
  type: Object
})], Field_Field.prototype, "errors", null);

class CompoundField extends Field_Field {
  renderHeader() {}

  includeOptionalField(fields, include, type, name, helpText, autocomplete) {
    if (include) {
      fields.push({
        type: type,
        name: name,
        helpText: helpText,
        autocomplete: autocomplete
      });
    }
  }

}
// CONCATENATED MODULE: ./packages/formsey-core/FieldDefinitions.ts
class Option {}
class Image {}
class Selection {}
// CONCATENATED MODULE: ./packages/formsey-core/FocusEvent.ts
class FocusEvent extends CustomEvent {
  constructor(name) {
    super("focus", {
      bubbles: true,
      composed: true,
      detail: {
        name
      }
    });
  }

}
// EXTERNAL MODULE: ./packages/formsey-core/InvalidEvent.ts
var InvalidEvent = __webpack_require__(5);

// CONCATENATED MODULE: ./packages/formsey-core/styles.ts

const NATIVE_STYLES = lit_element["b" /* css */]`
    button {
      display: flex;
      align-items: center;
      overflow: hidden;
      white-space: nowrap;
    }
    button:hover:not([disabled]) {
      cursor: pointer;
      background-color: var(--fs-widget-background-color-hover);
    }
    button:focus:not([disabled]) {
      border-color: var(--fs-border-color-focus);
    }
    button:active:not([disabled]) {
      background-color: var(--fs-widget-background-color-selected);
    }
    button:disabled {
      opacity: 0.5;
    }
    button.primary {
      background-color: var(--fs-accent-color);
      color: var(--fs-accent-color-text);
      text-transform: uppercase;
    }
    button.primary:hover {
      background-color: var(--fs-accent-color-hover);
    }

    input[type="checkbox"], input[type="radio"] {
      margin: var(--fs-widget-padding, 0 .5em 0 0);
      font-family: var(--formsey-font-family, var(--fs-font-family, inherit));
      font-size: var(--formsey-font-size, var(--fs-font-size, inherit));
      color: var(--formsey-text-color, var(--fs-text-color, inherit));
    }

    input[type="color"] {
      opacity: 0;
      position: absolute;
      top: 0;
      right: 0;
      display: block;
      width: 1.8em;
      height: 1.8em;
      border: none;
      padding: 0 1px;
    }

    label {
      display: flex;
      align-items: center;
      box-sizing: border-box;
    }

    .input {
      user-select: auto;
      outline: none;
      box-sizing: border-box;
      width: 100%;
      height: var(--formsey-input-height, 2em);
      font-family: var(--formsey-font-family, var(--fs-font-family, inherit));
      font-size: var(--formsey-font-size, var(--fs-font-size, inherit));
      color: var(--formsey-text-color, var(--fs-text-color, inherit));
      font-weight: var(--formsey-font-weight, var(--fs-font-weight, inherit));
      border-radius: var(--formsey-input-border-radius, var(--fs-border-radius, 3px));
      padding: var(--formsey-input-padding, var(--fs-widget-padding, .2em .3em));
      background: var(--formsey-input-background, var(--fs-widget-background-color-alpha, #99999920));
      border: var(--formsey-input-border, 1px solid transparent);
      transition: border 0.12s ease-out;
    }

    .input:focus-within {
      border: 1px solid var(--formsey-border-color-focus, var(--fs-border-color-focus, #020b2f));
    }

    /* Boolean Field */
    .bfl {
      height: var(--formsey-input-height, 2em);
    }

    /* Checkboxes Field / Multiple Choice Field*/
    formsey-checkboxes .options, formsey-multiple-choice .options {
      display: grid;
      grid-template-columns: 1fr;
      grid-gap: 4px;
    }
    formsey-checkboxes .other, formsey-multiple-choice .other {
      display: grid;
      grid-template-columns: max-content 1fr;
      grid-gap: 2em;
      align-items: center;
    }

    /* Form Field */
    formsey-form-field fieldset {
      padding: 5px;
      border: 0;
      margin: 0;
      min-width: 0;
    }
    .fft {
      font-size: var(--formsey-title-font-size, larger);
      font-family: var(--formsey-title-font-family, var(--formsey-font-family, inherit));
      font-weight: var(--formsey-title-font-weight, inherit);
      line-height: var(--formsey-title-line-height, inherit);
      color: var(--formsey-title-color, inherit);
      margin: var(--formsey-title-margin, var(--fs-padding, 12px 0 4px 0));
      padding: 0;
    }
    .ffd {
      font-size: var(--formsey-description-font-size, inherit);
      font-family: var(--formsey-description-font-family, var(--formsey-font-family, inherit));
      font-weight: var(--formsey-description-font-weight, inherit);
      line-height: var(--formsey-description-line-height, inherit);
      color: var(--formsey-description-color, #757c98);
      margin: var(--formsey-description-margin, var(--fs-padding, 12px 0 4px 0));
    }
    .ffg {
      display: inline-grid;
      grid-gap: 5px 5px;
      width: 100%;
      box-sizing: border-box;
    }
    .fff {
      width: 100%;
    }

    /* Nested form field */
    .nf .fft {
      font-size: var(--formsey-title-font-size, larger);
      font-family: var(--formsey-title-font-family, var(--formsey-font-family, inherit));
      font-weight: var(--formsey-title-font-weight, inherit);
      line-height: var(--formsey-title-line-height, inherit);
      color: var(--formsey-title-color, inherit);
      margin: var(--formsey-title-margin, var(--fs-padding, 12px 0 4px 0));
    }

    .nf .ffd {
      font-size: var(--formsey-description-font-size, inherit);
      font-family: var(--formsey-description-font-family, var(--formsey-font-family, inherit));
      font-weight: var(--formsey-description-font-weight, inherit);
      line-height: var(--formsey-description-line-height, inherit);
      color: var(--formsey-description-color, #757c98);
      margin: var(--formsey-description-margin, var(--fs-padding, 12px 0 4px 0));
    }

    /* .Color field */
    .cf {
      position: relative;
      width: 100%;
    }

    .cf input[type="text"] {
      text-transform: uppercase;
    }


    .cfp {
      position: absolute;
      top: 0;
      right: 0;
      margin: .4em;
      width: 1.2em;
      height: 1.2em;
      border-radius: 50%;
    }

    .cf svg {
      width: 1.2em;
      height: 1.2em;
     }

    /* Labeled field */
    .lfw {
      box-sizing: border-box;
      transition: all 0.2s ease-out;
      display: flex;
      flex-direction: column;
    }

    .lfl {
      font-family: var(--formsey-label-font-family, var(--formsey-font-family, inherit));
      font-size: var(--formsey-label-font-size, inherit);
      font-weight: var(--formsey-label-font-weight, inherit);
      color: var(--formsey-label-color, inherit);
      line-height: var(--formsey-label-line-height, inherit);
      padding: var(--formsey-label-padding, var(--fs-widget-padding, 4px 0 0 0));
      -webkit-font-smoothing: antialiased;
      transition: all 0.12s ease-out;
      opacity: 0.8;
    }

    .lfw:focus-within .lfl {
      color: var(--formsey-primary-color, var(--fs-accent-color, inherit));
      opacity: 1;
    }

    .lfi {
      background-color: var(--formsey-invalod_color, var(--fs-background-color-error, #AA000044));
      padding: 0 0.5em 0.1em;
      border-radius: var(--formsey-invalid-border-radius, var(--fs-border-radius-m, 0.3em));
    }

    .lfr {
      color: var(--formsey-required-color, var(--fs-text-color-error));
      margin: var(--formsey-required-margin, var(--fs-widget-padding, 0 0 0 4px));
      font-family: var(--formey-required-font-family, var(--formsey-font-family, inherit));
      font-size: var(--formey-required-font-size, smaller);
      line-height: var(--formsey-required-line-height, inherit);
      vertical-align: top;
    }

    .lfet, .lfht {
      font-family: var(--formey-help-text-font-family, var(--formsey-font-family, inherit));
      font-size: var(--formey-help-text-font-size, smaller);
      line-height: var(--formsey-help-text-line-height, inherit);
      margin: var(--formsey-help-text-margin, 1px 0 0 0);
    }

    .lfet {
      color: var(--formsey-error-text-color, var(--lumo-error-text-color, #FC0000));
    }

    .lfht {
      color: var(--formsey-help-text-color, inherit);
      padding: var(--formsey-help-text-padding, var(--fs-widget-padding, 4px 0 0 0));
      opacity: 0.8;
      transition: opacity 0.12s ease-out;
    }

    .lfw:focus-within .lfht {
      opacity: 1;
    }

    /* Image field */
    .if {
      width: 100%;
    }
    .if>img {
      max-width: 100%;
      height: auto;
    }

    /* Images field */
    .ifi {
      column-gap: 0px;
      line-height: 0;
    }


    formsey-image-checkbox {
      display: inline-block;
      position: relative;
    }
    formsey-image-checkbox input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    formsey-image-checkbox img {
      width: 100%;
      max-width: 100%;
      max-height: 100%;
      height: auto;
      opacity: .9;
      transition: opacity 0.2s ease-out, transform .2s;
      transform-origin: 50% 50%;
    }
    formsey-image-checkbox img:hover {
      opacity: .95;
    }
    formsey-image-checkbox :checked+label>img {
      opacity: 1;
    }
    formsey-image-checkbox label {
      display: flex;
      flex-direction: column;
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: transform .2s;
      line-height: 1.15;
      margin-bottom: .5em;
    }
    formsey-image-checkbox label::after {
      content: ' ';
      color: var(--formsey-text-color, var(--fs-accent-color-text, #ffffff));
      background-color: var(--formsey-background-color, var(--fs-background-color, inherit));
      border-radius: 50%;
      position: absolute;
      right: .25em;
      top: .25em;
      width: 1em;
      height: 1em;
      text-align: center;
      line-height: 1em;
      transform-origin: 50% 50%;
      display:none;
      box-shadow: var(--formsey-box-shadow, var(--fs-box-shadow));
    }
    formsey-image-checkbox :checked+label>img {
      box-shadow: 0px 0px 3px 0 var(--fs-text-color);
    }
    formsey-image-checkbox :focus+label {
      transform: scale(.95);
    }
    formsey-image-checkbox :checked+label {
      transform: scale(.9);
    }
    formsey-image-checkbox :focus+label>img {
      box-shadow: 0px 0px 3px 0 var(--fs-border-color-focus);
      opacity: .9;
    }
    formsey-image-checkbox :checked+label::after {
      display:block;
    }

    /* Sourcecode field */
    formsey-sourcecode .input {
      height: 150px;
      padding: 0;
      overflow: hidden;
    }

    /* Signature field */
    formsey-signature .input {
      position: relative;
      height: 150px;
    }

    formsey-signature .input:focus-within {
      border: 1px solid var(--formsey-primary-color,  #020b2f);
    }

    formsey-signature canvas {
      width: 100%;
      height: 100%;
      outline: none;
    }

    formsey-signature svg {
      position: absolute;
      width: 16px;
      right: 8px;
      top: 8px;
      fill: var(--formsey-signature-clear-icon-color, #757c98);
      stroke-width: 0;
      transition: fill 0.12s ease-out;
    }

    formsey-signature svg:hover {
      fill: var(--formsey-primary-color,  #020b2f);
    }

    /* Upload field */
    formsey-upload input[type="file"] {
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
    }

    formsey-upload .input {
      display: flex;
      flex-direction: column;
      cursor: pointer;
      height: auto;
      padding: 0;
    }

    formsey-upload .files, formsey-upload .prompt {
      line-height: initial;
      cursor: default;
      display: grid;
      grid-template-columns: 24px 1fr max-content 20px;
      grid-gap: 5px;
      align-items: center;
    }

    formsey-upload .prompt {
      flex-grow: 1;
      grid-template-columns: 1fr max-content;
      cursor: pointer;
      min-height: calc( var(--formsey-input-height, 2em) - 2px);
    }

    formsey-upload .prompt span {
      padding-left: 4px;
    }

    formsey-upload .prompt svg {
      width: 1.2em;
      height: 1.2em;
    }

    formsey-upload .files {
      font-size: var(--fs-font-size, smaller);
    }

    formsey-upload .preview, formsey-upload .preview svg {
      max-width:2em;
      max-height:2em;
      width: auto;
      height: auto;
      padding: 0.1em 0.3em;
    }

    formsey-upload .over {
      border: 1px dashed var(--formsey-primary-color, #999);
      color: var(--formsey-primary-color, #999);
    }

    formsey-upload .filename {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    formsey-upload .remove {
      outline: none;
    }

    formsey-upload .remove svg {
      margin-top: 3px;
      width: 1.2em;
      fill: currentColor;
      cursor: pointer;
    }

    /* YouTube field */
    formsey-youtube {
      display: table;
      width: 100%;
    }

    formsey-youtube .fs-video {
      position: relative;
      overflow: hidden;
      max-width: 100%;
    }

    formsey-youtube iframe {
      border: 0;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Text field */
    formsey-text .input {
      height: auto;
    }

    /* Repeating section */
    formsey-repeating-section .form {
      position: relative;
      margin: 0.5em 0 0 0.8em;
      padding: 0 0 5px 15px;
      border-left: 2px solid var(--fs-widget-background-color, #E2DDDB);
      font-size: var(--formsey-repeating-section-icon-size, inherit);
      transition: all 0.12s ease-out;
    }
    formsey-repeating-section .form:hover {
      border-left: 2px solid var(--fs-widget-background-color-hover, #CAC4C2);
    }
    formsey-repeating-section .fs-remove-wrapper {
      position: absolute;
      line-height: 0;
      padding: 0.4em 0;
      top: calc(50% - 1em);
      left: -0.8em;
    }
    formsey-repeating-section button svg {
      width: 1em;
      height: auto;
      stroke-width: 0;
      fill: var(--formsey-repeating-section-icon-fill-color, var(--fs-text-color, currentColor));
    }
    formsey-repeating-section button {
      display: flex;
      width: 1.4em;
      height: 1.4em;
      font-size: var(--formsey-repeating-section-icon-size, inherit);
      border-radius: 50%;
      background-color: var(--formsey-repeating-section-icon-background-color, var(--fs-widget-background-color, #E2DDDB));
      transition: background-color 0.12s ease-out;
      border: var(--formsey-input-border, 1px solid transparent);
      padding: 0.2em;
    }
    formsey-repeating-section button:focus {
      outline: none;
      border: 1px solid var(--formsey-border-color-focus, var(--fs-border-color-focus, #020b2f));
    }
    formsey-repeating-section .form:hover .fs-remove-wrapper {
      opacity: 1;
    }
    formsey-repeating-section .form:hover .fs-remove, formsey-repeating-section .fs-add:hover {
      background-color: var(--formsey-repeating-section-icon-hover-background-color, var(--fs-widget-background-color-hover, #CAC4C2));
    }
    formsey-repeating-section .fs-add {
      margin: 0.2em 0.1em 0.1em;
    }

    /* Selectable section */
    formsey-selectable-section .fft {
      margin: var(--formsey-selectable-title-margin, 4px 0 2px 0);
      font-size: var(--formsey-selectable-title-font-size, 18px);
    }

    formsey-selectable-section .ffd {
      margin: var(--formsey-selectable-title-margin, 4px 0 2px 0);
      font-size: var(--formsey-selectable-title-font-size, 16px);
    }

    /* Section field */
    formsey-section header {
      background-color: var(--lumo-primary-color);
      padding: var(--lumo-space-xs) var(--lumo-space-m);
      margin-top: var(--lumo-space-s);
      clip-path: polygon(5px 0, 100% 0%, calc(100% - 5px) 100%, 0% 100%);
    }

    formsey-section footer {
      padding: var(--lumo-space-s) 0 0 0;
    }
    `;
// CONCATENATED MODULE: ./packages/formsey-core/Form.ts
var Form_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





function get(data, path) {
  if (!data) {
    return undefined;
  }

  let tokens = path.split('.');
  let token = tokens.shift();
  path = tokens.join('.');
  let found;

  if (token.endsWith(']')) {
    let index = token.substring(token.indexOf('[') + 1, token.indexOf(']'));
    token = token.substring(0, token.indexOf('['));
    found = data[token][index];
  } else {
    found = data[token];
  }

  if (found && path) {
    return get(found, path);
  } else {
    return found;
  }
}
function set(data, path, value) {
  let tokens = path.split('.');
  let token = tokens.shift();
  path = tokens.join('.');

  if (token.endsWith(']')) {
    let index = token.substring(token.indexOf('[') + 1, token.indexOf(']'));
    token = token.substring(0, token.indexOf('['));

    if (path) {
      set(data[token][index], path, value);
    } else {
      data[token][index] = value;
      return;
    }
  } else {
    if (path) {
      set(data[token], path, value);
    } else {
      data[token] = value;
      return;
    }
  }
}
class Form_Form extends Field_Field {
  async fetchDefinition(url) {
    try {
      let response = await fetch(url);
      let data = await response.json();
      this.definition = data.definition;
      this.value = data.value;
      this.theme = data.theme;
      this.dispatchEvent(new CustomEvent('load', {
        detail: {
          definition: data.definition,
          value: data.value,
          theme: data.theme
        }
      }));
      this.requestUpdate();
    } catch (reason) {
      console.error(reason.message);
    }
  }

  set src(url) {
    this.fetchDefinition(url);
  }

  static get styles() {
    return [...super.styles, NATIVE_STYLES];
  }

  shouldUpdate() {
    let update = super.shouldUpdate();

    if (!update) {
      update = typeof this.definition === "undefined";
    }

    return update;
  }

  render() {
    var _a;

    let field = undefined;

    if (this.definition) {
      field = createField(this.components, this.definition, this.value, (_a = this.definition) === null || _a === void 0 ? void 0 : _a.name, this.errors, event => this.changed(event), event => this.invalid(event));
    }

    if (this.method && this.action) {
      return lit_element["e" /* html */]`<form action="${this.action}" method="${this.method}">${field}<slot></slot></form>`;
    } else {
      return field;
    }
  }

  createRenderRoot() {
    return this.attachShadow({
      mode: 'open'
    });
  }

  renderHeader() {
    return;
  }

  validate(report) {
    let child = this.renderRoot.firstElementChild;

    if (report) {
      return child.reportValidity();
    } else {
      return child.checkValidity();
    }
  }

  changed(e) {
    this.value = e.detail.value;

    if (e.detail.name.startsWith('.')) {
      e.detail.name = e.detail.name.substring(1);
    }

    let value;

    if (this.definition.name) {
      value = {};
      value[this.definition.name] = this.value;
    } else {
      value = this.value;
    }

    const key = e.detail.name ? e.detail.name : this.definition.name;

    if (e.type == "inputChange" || e.type == "input") {
      this.dispatchEvent(new ChangeEvent("input", key, value));
    }

    if (e.type == "inputChange" || e.type == "change") {
      this.dispatchEvent(new ChangeEvent("change", key, value));
    }
  }

  invalid(e) {
    e.stopPropagation();
    this.errors = e.errors;
    this.dispatchEvent(new InvalidEvent["b" /* InvalidEvent */](e.errors));
  }

  focusField(path) {
    var _a;

    let child = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.firstElementChild;

    if (child && typeof child['focusField'] === "function") {
      child.focusField(path);
    }
  }

  getValue(path) {
    return get(this.value, path);
  }

  setValue(path, value) {
    set(this.value, path, value);
    this.requestUpdate();
  }

  getField(path) {
    return get(this.definition, path);
  }

  setField(path, value) {
    set(this.definition, path, value);
    this.requestUpdate();
  }

}

Form_decorate([Object(lit_element["f" /* property */])()], Form_Form.prototype, "src", null);

Form_decorate([Object(lit_element["f" /* property */])()], Form_Form.prototype, "action", void 0);

Form_decorate([Object(lit_element["f" /* property */])()], Form_Form.prototype, "method", void 0);

register("formsey-form", Form_Form);
// EXTERNAL MODULE: ./node_modules/lit-html/directives/if-defined.js
var if_defined = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__(15);

// CONCATENATED MODULE: ./packages/formsey-core/FormField.ts
var FormField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






const SUPPORTED_BREAKPOINTS = ["xs", "s", "m", "l", "xl"];
const DEFAULT_BREAKPOINTS = {
  "xs": 320,
  "s": 568,
  "m": 768,
  "l": 1024,
  "xl": 1366
};
const DEFAULT_LAYOUT = "grid-template-columns:1fr;grid-gap:5px 5px";
class FormField_FormField extends Field_Field {
  constructor() {
    super();
    this.gridLayout = DEFAULT_LAYOUT;
    this._value = {};
    this.resizeObserver = new ResizeObserver_es["a" /* default */]((entries, observer) => {
      for (const entry of entries) {
        this.layout(entry.contentRect.width);
      }
    });
  }

  set value(value) {
    this._value = value;
    this.applyHiddenFields();
    this.removeDeletedFields();
    this.requestUpdate();
  }

  get value() {
    return this._value;
  }

  set definition(definition) {
    this._definition = definition;
    this.applyHiddenFields();
    this.removeDeletedFields();
    this.updateGridLayout();
    this.requestUpdate();
  }

  get definition() {
    return this._definition;
  }

  render() {
    let templates = [];
    let style = "padding:10px";

    if (this.definition.layout) {
      style = this.definition.layout.style;
    }

    if (this.definition.fields) {
      for (let field of this.definition.fields) {
        let fieldErrors = {};
        let value;

        if (field.hasOwnProperty('form') && !field.name) {
          // Anonymous nested form, so let's copy all form fields
          value = {};
          this.applyNestedFields(value, field);
          this.applyNestedErrors(fieldErrors, field);
        } else {
          value = this.value && field.name ? this.value[field.name] : undefined;

          if (this.errors) {
            for (let error in this.errors) {
              if (this.definition.name && (error == this.definition.name + "." + field.name || error.startsWith(this.definition.name + "." + field.name + ".") || error.startsWith(this.definition.name + "." + field.name + "["))) {
                fieldErrors[error.substring((this.definition.name + ".").length)] = this.errors[error];
              } else if (error.startsWith(field.name + "[")) {
                fieldErrors[error] = this.errors[error];
              } else if (error == field.name || error.startsWith(field.name + ".")) {
                fieldErrors[error] = this.errors[error];
              }
            }
          }
        }

        let fieldTemplate = lit_element["e" /* html */]`${createField(this.components, field, value, this.path(), fieldErrors, event => this.changed(event), event => this.invalid(event))}`;

        if (this.gridLayout.indexOf('grid-template-areas') >= 0) {
          templates.push(lit_element["e" /* html */]`<div class='fff' style="grid-area:_${formsey_core_area(field, this.definition.fields)}">${fieldTemplate}</div>`);
        } else {
          templates.push(lit_element["e" /* html */]`<div class='fff'>${fieldTemplate}</div>`);
        }
      }
    }

    let header = [];

    if (this.definition.label) {
      header.push(lit_element["e" /* html */]`<div class="fft">${this.definition.label}</div>`);
    }

    if (this.definition.helpText) {
      header.push(lit_element["e" /* html */]`<div class="ffd">${this.definition.helpText}</div>`);
    }

    return lit_element["e" /* html */]`<fieldset style="${Object(if_defined["a" /* ifDefined */])(style)}">${header}<div class="ffg" style="${this.gridLayout}" @gridSizeChanged="${this.gridSizeChanged}">${templates}</div></fieldset>`;
  }

  gridSizeChanged(e) {
    e.stopPropagation();
    this.dispatchEvent(new CustomEvent('gridSizeChanged', {
      bubbles: true,
      composed: true,
      detail: {
        id: this.domPath() + "." + e.detail.id,
        size: e.detail.size
      }
    }));
  }

  firstUpdated() {
    this.resizeObserver.observe(this.grid);
  }

  updated() {
    let counter = 0;

    for (let field of this._fields) {
      let child = field.firstElementChild;

      if (typeof child['setIndex'] == "function") {
        child.setIndex(counter);
        counter++;
      }
    }
  }

  validate(report) {
    let validity = true;

    for (let field of this._fields) {
      let child = field.firstElementChild;
      let valid;

      if (report) {
        valid = child.reportValidity();
      } else {
        valid = child.checkValidity();
      }

      if (!valid) {
        validity = false;
      }
    }

    return validity;
  }

  layout(availableWidth) {
    var _a, _b, _c; // If available with larger than larges breakpoint, default to the largest


    let detectedSize = SUPPORTED_BREAKPOINTS[SUPPORTED_BREAKPOINTS.length - 1];

    for (let size of SUPPORTED_BREAKPOINTS) {
      let breakpoint = (_c = (_b = (_a = this.definition) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.breakpoints) === null || _c === void 0 ? void 0 : _c[size];

      if (typeof breakpoint === "undefined") {
        breakpoint = DEFAULT_BREAKPOINTS[size];
      }

      if (breakpoint > availableWidth) {
        detectedSize = size;
        break;
      }
    }

    if (this.gridSize != detectedSize) {
      // console.log("Grid size in form=" + this.definition.name + " changed from '" + this.gridSize + "' to '" + size + "'")
      this.gridSize = detectedSize;
      this.updateGridLayout();
      this.dispatchEvent(new CustomEvent('gridSizeChanged', {
        bubbles: true,
        composed: true,
        detail: {
          id: this.domPath(),
          size: detectedSize
        }
      }));
    }
  }

  updateGridLayout() {
    var _a, _b, _c;

    let gridLayout = DEFAULT_LAYOUT;

    for (let size of SUPPORTED_BREAKPOINTS) {
      gridLayout = ((_c = (_b = (_a = this.definition) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.grids) === null || _c === void 0 ? void 0 : _c[size]) ? this.definition.layout.grids[size] : gridLayout;

      if (this.gridSize == size) {
        this.gridLayout = gridLayout ? gridLayout : this.gridLayout;
        break;
      }
    }
  }

  focusField(path) {
    var _a;

    if (path.startsWith(this.definition.name + ".")) {
      path = path.substring(this.definition.name.length + 1);
    }

    for (let field of this._fields) {
      let child = field.firstElementChild;

      if (child && path.startsWith((_a = child.definition) === null || _a === void 0 ? void 0 : _a.name) && typeof child['focusField'] == "function") {
        child.focusField(path);
      }
    }
  }

  changed(e) {
    var _a;

    e.stopPropagation();

    if (!this.value) {
      this.value = {};
    }

    if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.name) {
      let name = e.detail.name;

      if (name.startsWith('.')) {
        name = name.substring(1);
        this.value = Object.assign(Object.assign({}, this.value), e.detail.value);
      } else {
        name = this.firstPathElement(e.detail.name);
        this.value[name] = e.detail.value;
      }

      this.removeDeletedFields();
      this.dispatchEvent(new ChangeEvent(e.type, this.prependPath(e.detail.name), this.value));
    }
  }

  removeDeletedFields() {
    if (this._definition && this._definition.fields && this._value) {
      // Remove values from fields that have been removed from the definition
      let newValue = {};

      for (let field of this._definition.fields) {
        if (typeof field.name != "undefined" && typeof this.value[field.name] != "undefined") {
          newValue[field.name] = this.value[field.name];
        }

        if (field.hasOwnProperty('form') && !field.name) {
          this.addUnnamedNestedFormFields(newValue, field);
        }
      }

      this.addMemberValueIfPresent("type", newValue);
      this.addMemberValueIfPresent("layout", newValue);
      this._value = newValue;
    }
  }

  addUnnamedNestedFormFields(newValue, nestedFormField) {
    for (let field of nestedFormField.form.fields) {
      if (typeof field.name != "undefined" && typeof this.value[field.name] != "undefined") {
        newValue[field.name] = this.value[field.name];
      }

      if (field.hasOwnProperty('form') && !field.name) {
        this.addUnnamedNestedFormFields(newValue, field);
      }
    }
  }

  addMemberValueIfPresent(name, newValue) {
    if (typeof this.value[name] != "undefined") {
      newValue[name] = this.value[name];
    }
  }

  applyHiddenFields() {
    if (this._definition && this._definition.fields && this._value) {
      for (let field of this._definition.fields) {
        if (field.type == "hidden") {
          if (field.name && field.default) {
            this._value[field.name] = field.default;
          }
        }
      }
    }
  }

  applyNestedFields(value, field) {
    for (let nestedField of field.form.fields) {
      if (nestedField) {
        value[nestedField.name] = this.value[nestedField.name];

        if (nestedField.hasOwnProperty('form') && !nestedField.name) {
          this.applyNestedFields(value, nestedField);
        }
      }
    }
  }

  applyNestedErrors(fieldErrors, field) {
    for (let nestedField of field.form.fields) {
      if (nestedField) {
        if (this.errors) {
          for (let error in this.errors) {
            if (this.definition.name && (error == this.definition.name + "." + nestedField.name || error.startsWith(this.definition.name + "." + nestedField.name + ".") || error.startsWith(this.definition.name + "." + nestedField.name + "["))) {
              fieldErrors[error.substring((this.definition.name + ".").length)] = this.errors[error];
            } else if (error.startsWith(nestedField.name + "[")) {
              fieldErrors[error] = this.errors[error];
            } else if (error == nestedField.name || error.startsWith(nestedField.name + ".")) {
              fieldErrors[error] = this.errors[error];
            }
          }
        }

        if (nestedField.hasOwnProperty('form') && !nestedField.name) {
          this.applyNestedErrors(fieldErrors, nestedField);
        }
      }
    }
  }

  invalid(e) {
    e.stopPropagation();

    for (let error in e.errors) {
      this.errors[this.definition.name ? this.definition.name + "." + error : error] = e.errors[error];
    }

    this.dispatchEvent(new InvalidEvent["b" /* InvalidEvent */](this.errors));
  }

  domPath() {
    const container = this.closestElement(".fff", this);

    if (container && container.parentElement) {
      const index = [...Array.from(container.parentElement.children)].indexOf(container);
      return index;
    } else {
      return 0;
    }
  }

  closestElement(selector, base = this) {
    function __closestFrom(el) {
      if (!el || el === document || el === window) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      let found = el.closest(selector);
      return found ? found : __closestFrom(el.getRootNode().host);
    }

    return __closestFrom(base);
  }

}

FormField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], FormField_FormField.prototype, "value", null);

FormField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], FormField_FormField.prototype, "definition", null);

FormField_decorate([Object(lit_element["f" /* property */])()], FormField_FormField.prototype, "gridLayout", void 0);

FormField_decorate([Object(lit_element["h" /* queryAll */])(".fs-form-field")], FormField_FormField.prototype, "_fields", void 0);

FormField_decorate([Object(lit_element["g" /* query */])(".ffg")], FormField_FormField.prototype, "grid", void 0);

register("formsey-form-field", FormField_FormField, ["native", "vaadin"], "form", "@formsey/fields-native/FormField");
// EXTERNAL MODULE: ./node_modules/lit-html/directives/class-map.js
var class_map = __webpack_require__(14);

// CONCATENATED MODULE: ./packages/formsey-core/LabeledField.ts



class LabeledField_LabeledField extends Field_Field {
  render() {
    return lit_element["e" /* html */]`<div class="${Object(class_map["a" /* classMap */])({
      lfw: true,
      lfi: !this.valid && this.report
    })}">${this.renderHeader()}${this.renderField()}${this.renderFooter()}</div>`;
  }

  renderHeader() {
    let required = false;

    if (this.definition.hasOwnProperty('required')) {
      required = this.definition.required;
    }

    return lit_element["e" /* html */]`
      ${this.definition.label ? lit_element["e" /* html */]`<div class="lfl">${this.definition.label}${required ? lit_element["e" /* html */]`<span class="lfr">&#10033;</span>` : lit_element["e" /* html */]``}</div>` : undefined}`;
  }

  renderFooter() {
    let validityMessage = undefined;

    if (this.error) {
      if (this.definition.customValidity) {
        validityMessage = this.definition.customValidity;
      } else {
        validityMessage = this.error.validityMessage;
      }
    }

    let helpText = this.definition.helpText ? lit_element["e" /* html */]`<div class="lfht">${this.definition.helpText}</div>` : undefined;
    return this.report && validityMessage ? lit_element["e" /* html */]`<div class="lfet">${validityMessage}</div>` : helpText;
  }

}
// EXTERNAL MODULE: ./packages/formsey-core/NestedFormField.ts
var NestedFormField = __webpack_require__(16);

// CONCATENATED MODULE: ./packages/formsey-core/index.ts










function getThemes() {
  return window['__formseyThemes'];
}
function registerTheme(name, theme) {
  let themes = window['__formseyThemes'];

  if (typeof themes === "undefined") {
    console.log("Create themes registry");
    themes = {};
    window['__formseyThemes'] = themes;
  }

  let registeredTheme = themes[name];

  if (typeof registeredTheme !== "undefined") {
    console.log("Add components to registered theme='" + name + "'");
    themes[name] = Object.assign(Object.assign({}, registerTheme), {
      components: Object.assign(Object.assign({}, registeredTheme.components), theme.components)
    });
  } else {
    console.log("Add new theme='" + name + "' to registry");
    themes[name] = theme;
  }
}
function getTheme(name) {
  let themes = window['__formseyThemes'];
  return themes ? themes[name] : undefined;
}
function getDefaultTheme() {
  let themes = window['__formseyThemes'];

  if (typeof themes != "undefined") {
    let avaliableThemes = Object.keys(themes);

    if (avaliableThemes.length == 0) {
      return undefined;
    } else {
      return avaliableThemes[0];
    }
  }

  return undefined;
}
function register(tag, constructor, themes, type, importPath) {
  if (customElements.get(tag)) {
    console.log("'" + tag + "' already exists, skipping...");
    debugger;
  } else {
    console.log("Registering custom element=" + tag);
    customElements.define(tag, constructor);
  }

  if (themes && type && importPath) {
    themes = [].concat(themes);

    for (let theme of themes) {
      let components = {};
      components[type] = {
        tag,
        importPath
      };
      registerTheme(theme, {
        components
      });
    }
  }
}
function formsey_core_area(field, fields) {
  let area = field.name;

  if (!area) {
    let typeCounter = 0;
    area = field.type;
    fields.forEach(formField => {
      if (field === formField) {
        area += typeCounter;
      }

      if (formField.type === field.type) {
        typeCounter++;
      }
    });
  }

  return area;
}
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
    });
  });
}

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ifDefined; });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const previousValues = new WeakMap();
/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */

const ifDefined = Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__[/* directive */ "d"])(value => part => {
  const previousValue = previousValues.get(part);

  if (value === undefined && part instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__[/* AttributePart */ "a"]) {
    // If the value is undefined, remove the attribute, but only if the value
    // was previously defined.
    if (previousValue !== undefined || !previousValues.has(part)) {
      const name = part.committer.name;
      part.committer.element.removeAttribute(name);
    }
  } else if (value !== previousValue) {
    part.setValue(value);
  }

  previousValues.set(part, value);
});

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return marker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return nodeMarker; });
/* unused harmony export markerRegex */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return boundAttributeSuffix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Template; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isTemplatePartActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return createMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return lastAttributeNameRegex; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
/**
 * An expression marker used text-positions, multi-binding attributes, and
 * attributes with markup-like text values.
 */

const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
/**
 * Suffix appended to all bound attribute names.
 */

const boundAttributeSuffix = '$lit$';
/**
 * An updatable Template that tracks the location of dynamic parts.
 */

class Template {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    const walker = document.createTreeWalker(element.content, 133
    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
    , null, false); // Keeps track of the last index associated with a part. We try to delete
    // unnecessary nodes, but we never want to associate two different parts
    // to the same index. They must have a constant node between.

    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const {
      strings,
      values: {
        length
      }
    } = result;

    while (partIndex < length) {
      const node = walker.nextNode();

      if (node === null) {
        // We've exhausted the content inside a nested template element.
        // Because we still have parts (the outer for-loop), we know:
        // - There is a template in the stack
        // - The walker will find a nextNode outside the template
        walker.currentNode = stack.pop();
        continue;
      }

      index++;

      if (node.nodeType === 1
      /* Node.ELEMENT_NODE */
      ) {
          if (node.hasAttributes()) {
            const attributes = node.attributes;
            const {
              length
            } = attributes; // Per
            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
            // attributes are not guaranteed to be returned in document order.
            // In particular, Edge/IE can return them out of order, so we cannot
            // assume a correspondence between part index and attribute index.

            let count = 0;

            for (let i = 0; i < length; i++) {
              if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                count++;
              }
            }

            while (count-- > 0) {
              // Get the template literal section leading up to the first
              // expression in this attribute
              const stringForPart = strings[partIndex]; // Find the attribute name

              const name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
              // All bound attributes have had a suffix added in
              // TemplateResult#getHTML to opt out of special attribute
              // handling. To look up the attribute value we also need to add
              // the suffix.

              const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
              const attributeValue = node.getAttribute(attributeLookupName);
              node.removeAttribute(attributeLookupName);
              const statics = attributeValue.split(markerRegex);
              this.parts.push({
                type: 'attribute',
                index,
                name,
                strings: statics
              });
              partIndex += statics.length - 1;
            }
          }

          if (node.tagName === 'TEMPLATE') {
            stack.push(node);
            walker.currentNode = node.content;
          }
        } else if (node.nodeType === 3
      /* Node.TEXT_NODE */
      ) {
          const data = node.data;

          if (data.indexOf(marker) >= 0) {
            const parent = node.parentNode;
            const strings = data.split(markerRegex);
            const lastIndex = strings.length - 1; // Generate a new text node for each literal section
            // These nodes are also used as the markers for node parts

            for (let i = 0; i < lastIndex; i++) {
              let insert;
              let s = strings[i];

              if (s === '') {
                insert = createMarker();
              } else {
                const match = lastAttributeNameRegex.exec(s);

                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                  s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                }

                insert = document.createTextNode(s);
              }

              parent.insertBefore(insert, node);
              this.parts.push({
                type: 'node',
                index: ++index
              });
            } // If there's no text, we must insert a comment to mark our place.
            // Else, we can trust it will stick around after cloning.


            if (strings[lastIndex] === '') {
              parent.insertBefore(createMarker(), node);
              nodesToRemove.push(node);
            } else {
              node.data = strings[lastIndex];
            } // We have a part for each match found


            partIndex += lastIndex;
          }
        } else if (node.nodeType === 8
      /* Node.COMMENT_NODE */
      ) {
          if (node.data === marker) {
            const parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
            // the following are true:
            //  * We don't have a previousSibling
            //  * The previousSibling is already the start of a previous part

            if (node.previousSibling === null || index === lastPartIndex) {
              index++;
              parent.insertBefore(createMarker(), node);
            }

            lastPartIndex = index;
            this.parts.push({
              type: 'node',
              index
            }); // If we don't have a nextSibling, keep this node so we have an end.
            // Else, we can remove it to save future costs.

            if (node.nextSibling === null) {
              node.data = '';
            } else {
              nodesToRemove.push(node);
              index--;
            }

            partIndex++;
          } else {
            let i = -1;

            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
              // Comment node has a binding marker inside, make an inactive part
              // The binding won't work, but subsequent bindings will
              // TODO (justinfagnani): consider whether it's even worth it to
              // make bindings in comments work
              this.parts.push({
                type: 'node',
                index: -1
              });
              partIndex++;
            }
          }
        }
    } // Remove text binding nodes after the walk to not disturb the TreeWalker


    for (const n of nodesToRemove) {
      n.parentNode.removeChild(n);
    }
  }

}

const endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};

const isTemplatePartActive = part => part.index !== -1; // Allows `document.createComment('')` to be renamed for a
// small manual size-savings.

const createMarker = () => document.createComment('');
/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-characters
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
 * space character except " ".
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */

const lastAttributeNameRegex = // eslint-disable-next-line no-control-regex
/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ directive["a" /* directive */]; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ part["a" /* noChange */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ parts["b" /* AttributePart */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ parts["e" /* NodePart */]; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ parts["g" /* PropertyPart */]; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ template_factory["b" /* templateFactory */]; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ html; });

// UNUSED EXPORTS: DefaultTemplateProcessor, defaultTemplateProcessor, isDirective, removeNodes, reparentNodes, nothing, AttributeCommitter, BooleanAttributePart, EventPart, isIterable, isPrimitive, PropertyCommitter, parts, render, templateCaches, TemplateInstance, SVGTemplateResult, TemplateResult, createMarker, isTemplatePartActive, Template, svg

// EXTERNAL MODULE: ./node_modules/lit-html/lib/parts.js
var parts = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/lit-html/lib/default-template-processor.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Creates Parts when a template is instantiated.
 */

class default_template_processor_DefaultTemplateProcessor {
  /**
   * Create parts for an attribute-position binding, given the event, attribute
   * name, and string literals.
   *
   * @param element The element containing the binding
   * @param name  The attribute name
   * @param strings The string literals. There are always at least two strings,
   *   event for fully-controlled bindings with a single expression.
   */
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];

    if (prefix === '.') {
      const committer = new parts["f" /* PropertyCommitter */](element, name.slice(1), strings);
      return committer.parts;
    }

    if (prefix === '@') {
      return [new parts["d" /* EventPart */](element, name.slice(1), options.eventContext)];
    }

    if (prefix === '?') {
      return [new parts["c" /* BooleanAttributePart */](element, name.slice(1), strings)];
    }

    const committer = new parts["a" /* AttributeCommitter */](element, name, strings);
    return committer.parts;
  }
  /**
   * Create parts for a text-position binding.
   * @param templateFactory
   */


  handleTextExpression(options) {
    return new parts["e" /* NodePart */](options);
  }

}
const defaultTemplateProcessor = new default_template_processor_DefaultTemplateProcessor();
// EXTERNAL MODULE: ./node_modules/lit-html/lib/template-result.js
var template_result = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/directive.js
var directive = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/part.js
var part = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/render.js
var render = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/template-factory.js
var template_factory = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/template-instance.js
var template_instance = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/lit-html/lib/template.js
var template = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 *
 * Main lit-html module.
 *
 * Main exports:
 *
 * -  [[html]]
 * -  [[svg]]
 * -  [[render]]
 *
 * @module lit-html
 * @preferred
 */

/**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */



 // TODO(justinfagnani): remove line when we get NodePart moving methods








 // IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for lit-html usage.
// TODO(justinfagnani): inject version number at build time

if (typeof window !== 'undefined') {
  (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.2.1');
}
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */


const html = (strings, ...values) => new template_result["b" /* TemplateResult */](strings, values, 'html', defaultTemplateProcessor);
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */

const svg = (strings, ...values) => new template_result["a" /* SVGTemplateResult */](strings, values, 'svg', defaultTemplateProcessor);

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InvalidError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return InvalidEvent; });
class InvalidError {
  constructor(validityMessage, custom, validityState) {
    this.validityMessage = validityMessage;

    if (custom) {
      this.custom = custom;
    }

    if (validityState) {
      this.validityState = validityState;
    }
  }

}
class InvalidEvent extends Event {
  constructor(errors) {
    super("invalid");

    if (errors) {
      this.errors = errors;
    } else {
      this.errors = {};
    }
  }

  addError(path, error) {
    this.errors[path] = error;
  }

}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isPrimitive; });
/* unused harmony export isIterable */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AttributeCommitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AttributePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return NodePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BooleanAttributePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return PropertyCommitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return PropertyPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return EventPart; });
/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _part_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _template_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var _template_result_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */






const isPrimitive = value => {
  return value === null || !(typeof value === 'object' || typeof value === 'function');
};
const isIterable = value => {
  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  !!(value && value[Symbol.iterator]);
};
/**
 * Writes attribute values to the DOM for a group of AttributeParts bound to a
 * single attribute. The value is only set once even if there are multiple parts
 * for an attribute.
 */

class AttributeCommitter {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];

    for (let i = 0; i < strings.length - 1; i++) {
      this.parts[i] = this._createPart();
    }
  }
  /**
   * Creates a single part. Override this to create a differnt type of part.
   */


  _createPart() {
    return new AttributePart(this);
  }

  _getValue() {
    const strings = this.strings;
    const l = strings.length - 1;
    let text = '';

    for (let i = 0; i < l; i++) {
      text += strings[i];
      const part = this.parts[i];

      if (part !== undefined) {
        const v = part.value;

        if (isPrimitive(v) || !isIterable(v)) {
          text += typeof v === 'string' ? v : String(v);
        } else {
          for (const t of v) {
            text += typeof t === 'string' ? t : String(t);
          }
        }
      }
    }

    text += strings[l];
    return text;
  }

  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }

}
/**
 * A Part that controls all or part of an attribute value.
 */

class AttributePart {
  constructor(committer) {
    this.value = undefined;
    this.committer = committer;
  }

  setValue(value) {
    if (value !== _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"] && (!isPrimitive(value) || value !== this.value)) {
      this.value = value; // If the value is a not a directive, dirty the committer so that it'll
      // call setAttribute. If the value is a directive, it'll dirty the
      // committer if it calls setValue().

      if (!Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__[/* isDirective */ "b"])(value)) {
        this.committer.dirty = true;
      }
    }
  }

  commit() {
    while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__[/* isDirective */ "b"])(this.value)) {
      const directive = this.value;
      this.value = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"];
      directive(this);
    }

    if (this.value === _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"]) {
      return;
    }

    this.committer.commit();
  }

}
/**
 * A Part that controls a location within a Node tree. Like a Range, NodePart
 * has start and end locations and can set and update the Nodes between those
 * locations.
 *
 * NodeParts support several value types: primitives, Nodes, TemplateResults,
 * as well as arrays and iterables of those types.
 */

class NodePart {
  constructor(options) {
    this.value = undefined;
    this.__pendingValue = undefined;
    this.options = options;
  }
  /**
   * Appends this part into a container.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  appendInto(container) {
    this.startNode = container.appendChild(Object(_template_js__WEBPACK_IMPORTED_MODULE_5__[/* createMarker */ "c"])());
    this.endNode = container.appendChild(Object(_template_js__WEBPACK_IMPORTED_MODULE_5__[/* createMarker */ "c"])());
  }
  /**
   * Inserts this part after the `ref` node (between `ref` and `ref`'s next
   * sibling). Both `ref` and its next sibling must be static, unchanging nodes
   * such as those that appear in a literal section of a template.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  /**
   * Appends this part into a parent part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  appendIntoPart(part) {
    part.__insert(this.startNode = Object(_template_js__WEBPACK_IMPORTED_MODULE_5__[/* createMarker */ "c"])());

    part.__insert(this.endNode = Object(_template_js__WEBPACK_IMPORTED_MODULE_5__[/* createMarker */ "c"])());
  }
  /**
   * Inserts this part after the `ref` part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  insertAfterPart(ref) {
    ref.__insert(this.startNode = Object(_template_js__WEBPACK_IMPORTED_MODULE_5__[/* createMarker */ "c"])());

    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }

  setValue(value) {
    this.__pendingValue = value;
  }

  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }

    while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__[/* isDirective */ "b"])(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"];
      directive(this);
    }

    const value = this.__pendingValue;

    if (value === _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"]) {
      return;
    }

    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof _template_result_js__WEBPACK_IMPORTED_MODULE_4__[/* TemplateResult */ "b"]) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === _part_js__WEBPACK_IMPORTED_MODULE_2__[/* nothing */ "b"]) {
      this.value = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* nothing */ "b"];
      this.clear();
    } else {
      // Fallback, will render the string representation
      this.__commitText(value);
    }
  }

  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }

  __commitNode(value) {
    if (this.value === value) {
      return;
    }

    this.clear();

    this.__insert(value);

    this.value = value;
  }

  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
    // it can't be implicitly converted - i.e. it's a symbol.

    const valueAsString = typeof value === 'string' ? value : String(value);

    if (node === this.endNode.previousSibling && node.nodeType === 3
    /* Node.TEXT_NODE */
    ) {
        // If we only have a single text node between the markers, we can just
        // set its value, rather than replacing it.
        // TODO(justinfagnani): Can we just check if this.value is primitive?
        node.data = valueAsString;
      } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }

    this.value = value;
  }

  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);

    if (this.value instanceof _template_instance_js__WEBPACK_IMPORTED_MODULE_3__[/* TemplateInstance */ "a"] && this.value.template === template) {
      this.value.update(value.values);
    } else {
      // Make sure we propagate the template processor from the TemplateResult
      // so that we use its syntax extension, etc. The template factory comes
      // from the render function options so that it can control template
      // caching and preprocessing.
      const instance = new _template_instance_js__WEBPACK_IMPORTED_MODULE_3__[/* TemplateInstance */ "a"](template, value.processor, this.options);

      const fragment = instance._clone();

      instance.update(value.values);

      this.__commitNode(fragment);

      this.value = instance;
    }
  }

  __commitIterable(value) {
    // For an Iterable, we create a new InstancePart per item, then set its
    // value to the item. This is a little bit of overhead for every item in
    // an Iterable, but it lets us recurse easily and efficiently update Arrays
    // of TemplateResults that will be commonly returned from expressions like:
    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
    // If _value is an array, then the previous render was of an
    // iterable and _value will contain the NodeParts from the previous
    // render. If _value is not an array, clear this part and make a new
    // array for NodeParts.
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    } // Lets us keep track of how many items we stamped so we can clear leftover
    // items from a previous render


    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;

    for (const item of value) {
      // Try to reuse an existing part
      itemPart = itemParts[partIndex]; // If no existing part, create a new one

      if (itemPart === undefined) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);

        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }

      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }

    if (partIndex < itemParts.length) {
      // Truncate the parts array so _value reflects the current state
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }

  clear(startNode = this.startNode) {
    Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__[/* removeNodes */ "b"])(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }

}
/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */

class BooleanAttributePart {
  constructor(element, name, strings) {
    this.value = undefined;
    this.__pendingValue = undefined;

    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
      throw new Error('Boolean attributes can only contain a single expression');
    }

    this.element = element;
    this.name = name;
    this.strings = strings;
  }

  setValue(value) {
    this.__pendingValue = value;
  }

  commit() {
    while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__[/* isDirective */ "b"])(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"];
      directive(this);
    }

    if (this.__pendingValue === _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"]) {
      return;
    }

    const value = !!this.__pendingValue;

    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, '');
      } else {
        this.element.removeAttribute(this.name);
      }

      this.value = value;
    }

    this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"];
  }

}
/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */

class PropertyCommitter extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
  }

  _createPart() {
    return new PropertyPart(this);
  }

  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }

    return super._getValue();
  }

  commit() {
    if (this.dirty) {
      this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any

      this.element[this.name] = this._getValue();
    }
  }

}
class PropertyPart extends AttributePart {} // Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the third
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.

let eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
// blocks right into the body of a module

(() => {
  try {
    const options = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }

    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any

    window.removeEventListener('test', options, options);
  } catch (_e) {// event options not supported
  }
})();

class EventPart {
  constructor(element, eventName, eventContext) {
    this.value = undefined;
    this.__pendingValue = undefined;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;

    this.__boundHandleEvent = e => this.handleEvent(e);
  }

  setValue(value) {
    this.__pendingValue = value;
  }

  commit() {
    while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__[/* isDirective */ "b"])(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"];
      directive(this);
    }

    if (this.__pendingValue === _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"]) {
      return;
    }

    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }

    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }

    this.value = newListener;
    this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__[/* noChange */ "a"];
  }

  handleEvent(event) {
    if (typeof this.value === 'function') {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }

} // We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.

const getOptions = o => o && (eventOptionsSupported ? {
  capture: o.capture,
  passive: o.passive,
  once: o.once
} : o.capture);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return noChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nothing; });
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = {};
/**
 * A sentinel value that signals a NodePart to fully clear its content.
 */

const nothing = {};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isCEPolyfill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return reparentNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return removeNodes; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * True if the custom elements polyfill is in use.
 */
const isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;
/**
 * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
 * into another container (could be the same container), before `before`. If
 * `before` is null, it appends the nodes to the container.
 */

const reparentNodes = (container, start, end = null, before = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.insertBefore(start, before);
    start = n;
  }
};
/**
 * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
 * `container`.
 */

const removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.removeChild(start);
    start = n;
  }
};

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return templateFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return templateCaches; });
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */

function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);

  if (templateCache === undefined) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    templateCaches.set(result.type, templateCache);
  }

  let template = templateCache.stringsArray.get(result.strings);

  if (template !== undefined) {
    return template;
  } // If the TemplateStringsArray is new, generate a key from the strings
  // This key is shared between all templates with identical content


  const key = result.strings.join(_template_js__WEBPACK_IMPORTED_MODULE_0__[/* marker */ "f"]); // Check if we already have a Template for this key

  template = templateCache.keyString.get(key);

  if (template === undefined) {
    // If we have not seen this key before, create a new Template
    template = new _template_js__WEBPACK_IMPORTED_MODULE_0__[/* Template */ "a"](result, result.getTemplateElement()); // Cache the Template for this key

    templateCache.keyString.set(key, template);
  } // Cache all future queries for this TemplateStringsArray


  templateCache.stringsArray.set(result.strings, template);
  return template;
}
const templateCaches = new Map();

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _parts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _template_factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */



const parts = new WeakMap();
/**
 * Renders a template result or other value to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result Any value renderable by NodePart - typically a TemplateResult
 *     created by evaluating a template tag like `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param options RenderOptions for the entire render tree rendered to this
 *     container. Render options must *not* change between renders to the same
 *     container, as those changes will not effect previously rendered DOM.
 */

const render = (result, container, options) => {
  let part = parts.get(container);

  if (part === undefined) {
    Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__[/* removeNodes */ "b"])(container, container.firstChild);
    parts.set(container, part = new _parts_js__WEBPACK_IMPORTED_MODULE_1__[/* NodePart */ "e"](Object.assign({
      templateFactory: _template_factory_js__WEBPACK_IMPORTED_MODULE_2__[/* templateFactory */ "b"]
    }, options)));
    part.appendInto(container);
  }

  part.setValue(result);
  part.commit();
};

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return directive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isDirective; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = new WeakMap();
/**
 * Brands a function as a directive factory function so that lit-html will call
 * the function during template rendering, rather than passing as a value.
 *
 * A _directive_ is a function that takes a Part as an argument. It has the
 * signature: `(part: Part) => void`.
 *
 * A directive _factory_ is a function that takes arguments for data and
 * configuration and returns a directive. Users of directive usually refer to
 * the directive factory as the directive. For example, "The repeat directive".
 *
 * Usually a template author will invoke a directive factory in their template
 * with relevant arguments, which will then return a directive function.
 *
 * Here's an example of using the `repeat()` directive factory that takes an
 * array and a function to render an item:
 *
 * ```js
 * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
 * ```
 *
 * When `repeat` is invoked, it returns a directive function that closes over
 * `items` and the template function. When the outer template is rendered, the
 * return directive function is called with the Part for the expression.
 * `repeat` then performs it's custom logic to render multiple items.
 *
 * @param f The directive factory function. Must be a function that returns a
 * function of the signature `(part: Part) => void`. The returned function will
 * be called with the part object.
 *
 * @example
 *
 * import {directive, html} from 'lit-html';
 *
 * const immutable = directive((v) => (part) => {
 *   if (part.value !== v) {
 *     part.setValue(v)
 *   }
 * });
 */

const directive = f => (...args) => {
  const d = f(...args);
  directives.set(d, true);
  return d;
};
const isDirective = o => {
  return typeof o === 'function' && directives.has(o);
};

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TemplateResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SVGTemplateResult; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */


const commentMarker = ` ${_template_js__WEBPACK_IMPORTED_MODULE_1__[/* marker */ "f"]} `;
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */

class TemplateResult {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  /**
   * Returns a string of HTML used to create a `<template>` element.
   */


  getHTML() {
    const l = this.strings.length - 1;
    let html = '';
    let isCommentBinding = false;

    for (let i = 0; i < l; i++) {
      const s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
      // into the template source before it's parsed by the browser's HTML
      // parser. The marker type is based on whether the expression is in an
      // attribute, text, or comment position.
      //   * For node-position bindings we insert a comment with the marker
      //     sentinel as its text content, like <!--{{lit-guid}}-->.
      //   * For attribute bindings we insert just the marker sentinel for the
      //     first binding, so that we support unquoted attribute bindings.
      //     Subsequent bindings can use a comment marker because multi-binding
      //     attributes must be quoted.
      //   * For comment bindings we insert just the marker sentinel so we don't
      //     close the comment.
      //
      // The following code scans the template source, but is *not* an HTML
      // parser. We don't need to track the tree structure of the HTML, only
      // whether a binding is inside a comment, and if not, if it appears to be
      // the first binding in an attribute.

      const commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
      // comment close. Because <-- can appear in an attribute value there can
      // be false positives.

      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the
      // expression. This can match "name=value" like structures in text,
      // comments, and attribute values, so there can be false-positives.

      const attributeMatch = _template_js__WEBPACK_IMPORTED_MODULE_1__[/* lastAttributeNameRegex */ "e"].exec(s);

      if (attributeMatch === null) {
        // We're only in this branch if we don't have a attribute-like
        // preceding sequence. For comments, this guards against unusual
        // attribute values like <div foo="<!--${'bar'}">. Cases like
        // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
        // below.
        html += s + (isCommentBinding ? commentMarker : _template_js__WEBPACK_IMPORTED_MODULE_1__[/* nodeMarker */ "g"]);
      } else {
        // For attributes we use just a marker sentinel, and also append a
        // $lit$ suffix to the name to opt-out of attribute-specific parsing
        // that IE and Edge do for style and certain SVG attributes.
        html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + _template_js__WEBPACK_IMPORTED_MODULE_1__[/* boundAttributeSuffix */ "b"] + attributeMatch[3] + _template_js__WEBPACK_IMPORTED_MODULE_1__[/* marker */ "f"];
      }
    }

    html += this.strings[l];
    return html;
  }

  getTemplateElement() {
    const template = document.createElement('template');
    template.innerHTML = this.getHTML();
    return template;
  }

}
/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the `<svg>` tag so that
 * clones only container the original fragment.
 */

class SVGTemplateResult extends TemplateResult {
  getHTML() {
    return `<svg>${super.getHTML()}</svg>`;
  }

  getTemplateElement() {
    const template = super.getTemplateElement();
    const content = template.content;
    const svgElement = content.firstChild;
    content.removeChild(svgElement);
    Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__[/* reparentNodes */ "c"])(content, svgElement.firstChild);
    return template;
  }

}

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TemplateInstance; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */


/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */

class TemplateInstance {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }

  update(values) {
    let i = 0;

    for (const part of this.__parts) {
      if (part !== undefined) {
        part.setValue(values[i]);
      }

      i++;
    }

    for (const part of this.__parts) {
      if (part !== undefined) {
        part.commit();
      }
    }
  }

  _clone() {
    // There are a number of steps in the lifecycle of a template instance's
    // DOM fragment:
    //  1. Clone - create the instance fragment
    //  2. Adopt - adopt into the main document
    //  3. Process - find part markers and create parts
    //  4. Upgrade - upgrade custom elements
    //  5. Update - set node, attribute, property, etc., values
    //  6. Connect - connect to the document. Optional and outside of this
    //     method.
    //
    // We have a few constraints on the ordering of these steps:
    //  * We need to upgrade before updating, so that property values will pass
    //    through any property setters.
    //  * We would like to process before upgrading so that we're sure that the
    //    cloned fragment is inert and not disturbed by self-modifying DOM.
    //  * We want custom elements to upgrade even in disconnected fragments.
    //
    // Given these constraints, with full custom elements support we would
    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
    //
    // But Safari does not implement CustomElementRegistry#upgrade, so we
    // can not implement that order and still have upgrade-before-update and
    // upgrade disconnected fragments. So we instead sacrifice the
    // process-before-upgrade constraint, since in Custom Elements v1 elements
    // must not modify their light DOM in the constructor. We still have issues
    // when co-existing with CEv0 elements like Polymer 1, and with polyfills
    // that don't strictly adhere to the no-modification rule because shadow
    // DOM, which may be created in the constructor, is emulated by being placed
    // in the light DOM.
    //
    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
    // in one step.
    //
    // The Custom Elements v1 polyfill supports upgrade(), so the order when
    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
    // Connect.
    const fragment = _dom_js__WEBPACK_IMPORTED_MODULE_0__[/* isCEPolyfill */ "a"] ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    const walker = document.createTreeWalker(fragment, 133
    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
    , null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode(); // Loop through all the nodes and parts of a template

    while (partIndex < parts.length) {
      part = parts[partIndex];

      if (!Object(_template_js__WEBPACK_IMPORTED_MODULE_1__[/* isTemplatePartActive */ "d"])(part)) {
        this.__parts.push(undefined);

        partIndex++;
        continue;
      } // Progress the tree walker until we find our next part's node.
      // Note that multiple parts may share the same node (attribute parts
      // on a single element), so this loop may not run at all.


      while (nodeIndex < part.index) {
        nodeIndex++;

        if (node.nodeName === 'TEMPLATE') {
          stack.push(node);
          walker.currentNode = node.content;
        }

        if ((node = walker.nextNode()) === null) {
          // We've exhausted the content inside a nested template element.
          // Because we still have parts (the outer for-loop), we know:
          // - There is a template in the stack
          // - The walker will find a nextNode outside the template
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      } // We've arrived at our part's node.


      if (part.type === 'node') {
        const part = this.processor.handleTextExpression(this.options);
        part.insertAfterNode(node.previousSibling);

        this.__parts.push(part);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }

      partIndex++;
    }

    if (_dom_js__WEBPACK_IMPORTED_MODULE_0__[/* isCEPolyfill */ "a"]) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }

    return fragment;
  }

}

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return classMap; });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
 // IE11 doesn't support classList on SVG elements, so we emulate it with a Set

class ClassList {
  constructor(element) {
    this.classes = new Set();
    this.changed = false;
    this.element = element;
    const classList = (element.getAttribute('class') || '').split(/\s+/);

    for (const cls of classList) {
      this.classes.add(cls);
    }
  }

  add(cls) {
    this.classes.add(cls);
    this.changed = true;
  }

  remove(cls) {
    this.classes.delete(cls);
    this.changed = true;
  }

  commit() {
    if (this.changed) {
      let classString = '';
      this.classes.forEach(cls => classString += cls + ' ');
      this.element.setAttribute('class', classString);
    }
  }

}
/**
 * Stores the ClassInfo object applied to a given AttributePart.
 * Used to unset existing values when a new ClassInfo object is applied.
 */


const previousClassesCache = new WeakMap();
/**
 * A directive that applies CSS classes. This must be used in the `class`
 * attribute and must be the only part used in the attribute. It takes each
 * property in the `classInfo` argument and adds the property name to the
 * element's `class` if the property value is truthy; if the property value is
 * falsey, the property name is removed from the element's `class`. For example
 * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
 * @param classInfo {ClassInfo}
 */

const classMap = Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__[/* directive */ "d"])(classInfo => part => {
  if (!(part instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__[/* AttributePart */ "a"]) || part instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__[/* PropertyPart */ "c"] || part.committer.name !== 'class' || part.committer.parts.length > 1) {
    throw new Error('The `classMap` directive must be used in the `class` attribute ' + 'and must be the only part in the attribute.');
  }

  const {
    committer
  } = part;
  const {
    element
  } = committer;
  let previousClasses = previousClassesCache.get(part);

  if (previousClasses === undefined) {
    // Write static classes once
    // Use setAttribute() because className isn't a string on SVG elements
    element.setAttribute('class', committer.strings.join(' '));
    previousClassesCache.set(part, previousClasses = new Set());
  }

  const classList = element.classList || new ClassList(element); // Remove old classes that no longer apply
  // We use forEach() instead of for-of so that re don't require down-level
  // iteration.

  previousClasses.forEach(name => {
    if (!(name in classInfo)) {
      classList.remove(name);
      previousClasses.delete(name);
    }
  }); // Add or remove classes based on their classMap value

  for (const name in classInfo) {
    const value = classInfo[name];

    if (value != previousClasses.has(name)) {
      // We explicitly want a loose truthy check of `value` because it seems
      // more convenient that '' and 0 are skipped.
      if (value) {
        classList.add(name);
        previousClasses.add(name);
      } else {
        classList.remove(name);
        previousClasses.delete(name);
      }
    }
  }

  if (typeof classList.commit === 'function') {
    classList.commit();
  }
});

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */

/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */


  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }

      return false;
    });
    return result;
  }

  return (
    /** @class */
    function () {
      function class_1() {
        this.__entries__ = [];
      }

      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function () {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */

      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */


      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);

        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.delete = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);

        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */


      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */


      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }

        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };

      return class_1;
    }()
  );
}();
/**
 * Detects whether window and document objects are available in current environment.
 */


var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

var global$1 = function () {
  if (typeof global !== 'undefined' && global.Math === Math) {
    return global;
  }

  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }

  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  } // eslint-disable-next-line no-new-func


  return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */


var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }

  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}(); // Defines minimum timeout before adding a trailing call.


var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */

function throttle(callback, delay) {
  var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */

  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }

    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */


  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */


  function proxy() {
    var timeStamp = Date.now();

    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      } // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.


      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }

    lastCallTime = timeStamp;
  }

  return proxy;
} // Minimum delay before invoking the update of observers.


var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.

var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */

var ResizeObserverController =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */

    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */

    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */

    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */


  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    } // Add listeners if they haven't been added yet.


    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */


  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer); // Remove observer if it's present in registry.

    if (~index) {
      observers.splice(index, 1);
    } // Remove listeners if controller has no connected observers.


    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */


  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.

    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */


  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    }); // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.

    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    } // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.


    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */


  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */


  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */


  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */


var defineConfigurable = function (target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }

  return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */


var getWindowOf = function (target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
  // provided element.

  return ownerGlobal || global$1;
}; // Placeholder of an empty content rectangle.


var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */

function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */


function getBordersSize(styles) {
  var positions = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }

  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */


function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};

  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }

  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */


function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */


function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.

  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }

  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.

  var width = toFloat(styles.width),
      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).

  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }

    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  } // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.


  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.

    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }

    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }

  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  } // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens


  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */


function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }

  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }

  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */


function createReadOnlyRect(_a) {
  var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */


function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */


var ResizeObservation =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */

    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */

    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */


  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */


  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };

  return ResizeObservation;
}();

var ResizeObserverEntry =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.

    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }

  return ResizeObserverEntry;
}();

var ResizeObserverSPI =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */

    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is already being observed.

    if (observations.has(target)) {
      return;
    }

    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this); // Force the update of observations.

    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is not being observed.

    if (!observations.has(target)) {
      return;
    }

    observations.delete(target);

    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;

    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }

    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */


  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };

  return ResizeObserverSPI;
}(); // Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.


var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */

var ResizeObserver =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }

    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }

  return ResizeObserver;
}(); // Expose public methods of ResizeObserver.


['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;

    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});

var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }

  return ResizeObserver;
}();

/* harmony default export */ __webpack_exports__["a"] = (index);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NestedFormField; });
/* harmony import */ var _formsey_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _InvalidEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class NestedFormField extends _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* Field */ "b"] {
  constructor() {
    super(...arguments);
    this.value = {};
  }

  render() {
    if (!this.value) {
      this.value = {};
    }

    this.definition.form.name = this.definition.name;
    return lit_element__WEBPACK_IMPORTED_MODULE_1__[/* html */ "e"]`<div class="nf">${Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* createField */ "f"])(this.components, this.definition.form, this.value, this.parentPath, this.errors, event => this.changed(event), event => this.invalid(event))}</div>`;
  }

  focusField(path) {
    var _a;

    let child = this.div.firstElementChild;

    if (child && path.startsWith((_a = child.definition) === null || _a === void 0 ? void 0 : _a.name) && typeof child['focusField'] == "function") {
      child.focusField(path);
    }
  }

  validate(report) {
    let child = this.div.firstElementChild;

    if (report) {
      return child.reportValidity();
    } else {
      return child.checkValidity();
    }
  }

  invalid(e) {
    e.stopPropagation();
    this.dispatchEvent(new _InvalidEvent__WEBPACK_IMPORTED_MODULE_2__[/* InvalidEvent */ "b"](e.errors));
  }

  changed(e) {
    e.stopPropagation();
    this.value = e.detail.value;
    this.dispatchEvent(new _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* ChangeEvent */ "a"](e.type, e.detail.name, this.value));
  }

}

__decorate([Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[/* query */ "g"])('div')], NestedFormField.prototype, "div", void 0);

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OptionalSectionField; });
/* harmony import */ var _formsey_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _formsey_core_InvalidEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class OptionalSectionField extends _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* Field */ "b"] {
  constructor() {
    super(...arguments);
    this.untouched = true;
  }

  shouldUpdate() {
    if (typeof this.definition === "undefined") {
      return false;
    } else if (typeof this.value === "undefined" && typeof this.definition.default != "undefined" && this.untouched) {
      this.value = this.definition.default;

      if (this.value && this.definition.name) {
        this.dispatchEvent(new _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* ChangeEvent */ "a"]("inputChange", this.definition.name, this.value));
      }
    }

    if (this.definition.hidden) {
      return false;
    }

    return true;
  }

  render() {
    let checked = false;

    if (this.value) {
      checked = true;
    }

    this.definition.form.name = this.definition.name;
    let form = checked ? lit_element__WEBPACK_IMPORTED_MODULE_2__[/* html */ "e"]`<div id="form">${Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* createField */ "f"])(this.components, this.definition.form, this.value, this.path(), this.errors, event => this.changed(event), event => this.invalid(event))}</div>` : undefined;
    return lit_element__WEBPACK_IMPORTED_MODULE_2__[/* html */ "e"]`${Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* createField */ "f"])(this.components, {
      type: "boolean",
      name: this.definition.name,
      label: this.definition.label,
      helpText: this.definition.helpText,
      disabled: this.definition.disabled,
      required: this.definition.required
    }, checked, this.path(), this.errors, event => this.selectionChanged(event), event => this.invalid(event))}
      ${form}`;
  }

  focusField(path) {
    var _a;

    if (this.form) {
      let child = this.form.firstElementChild;

      if (child && path.startsWith((_a = child.definition) === null || _a === void 0 ? void 0 : _a.name) && typeof child['focusField'] == "function") {
        child.focusField(path);
      }
    }
  }

  validate(report) {
    let checkbox = this.renderRoot.firstElementChild;
    let valid = true;

    if (report) {
      valid = checkbox.reportValidity();
    } else {
      valid = checkbox.checkValidity();
    }

    if (this.form) {
      let child = this.form.firstElementChild;

      if (report) {
        valid = valid && child.reportValidity();
      } else {
        valid = valid && child.checkValidity();
      }
    }

    return valid;
  }

  invalid(e) {
    e.stopPropagation();
    this.dispatchEvent(new _formsey_core_InvalidEvent__WEBPACK_IMPORTED_MODULE_1__[/* InvalidEvent */ "b"](e.errors));
  }

  selectionChanged(e) {
    this.value = e.detail.value ? {} : undefined;
    this.untouched = false;
    this.requestUpdate();
    this.dispatchEvent(new _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* ChangeEvent */ "a"]("inputChange", this.definition.name, this.value));
  }

  changed(e) {
    this.value = e.detail.value;
    this.requestUpdate();
    this.dispatchEvent(new _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* ChangeEvent */ "a"]("inputChange", e.detail.name, this.value));
  }

}

__decorate([Object(lit_element__WEBPACK_IMPORTED_MODULE_2__[/* property */ "f"])({
  converter: Object
})], OptionalSectionField.prototype, "value", void 0);

__decorate([Object(lit_element__WEBPACK_IMPORTED_MODULE_2__[/* query */ "g"])("#form")], OptionalSectionField.prototype, "form", void 0);

Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* register */ "i"])("formsey-optional-section", OptionalSectionField, "native", "optionalSection", "@formsey/fields-native/OptionalSectionField");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SelectableSectionValue */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SelectableSectionField; });
/* harmony import */ var _formsey_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class SelectableSectionValue {
  constructor() {
    this.value = {};
  }

}
class SelectableSectionField extends _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* LabeledField */ "d"] {
  renderField() {
    if (this.definition && this.definition.selections) {
      let values = this.definition.selections.map(selection => selection.value ? selection.value : selection.label);
      let options = this.definition.selections.map(selection => {
        return {
          label: selection.label,
          value: selection.value
        };
      });
      let index = 0;

      if (this.value && this.value.selection) {
        index = values.indexOf(this.value.selection);
      } else {
        this.value = {
          selection: values[0],
          value: {}
        };
      }

      let selection = this.definition.selections[index];
      let value = selection.label ? selection.label : selection.value;
      let errors = {};
      return lit_element__WEBPACK_IMPORTED_MODULE_1__[/* html */ "e"]`${Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* createField */ "f"])(this.components, {
        type: "list",
        name: "selection",
        label: this.definition.label,
        helpText: this.definition.helpText,
        options
      }, value, this.path(), errors, event => this.selectionChanged(event), null)}
      <div class="form">${Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* createField */ "f"])(this.components, selection.form, this.value ? this.value.value : undefined, this.path(), errors, event => this.changed(event), null)}</div>`;
    }

    return undefined;
  }

  selectionChanged(e) {
    let value = e.detail.value;
    let option = this.definition.selections.filter(selection => selection.value ? selection.value === value : selection.label === value)[0].value;

    if (option) {
      this.value.selection = option;
      this.value.value = {};
      this.requestUpdate();

      if (this.definition.name) {
        this.dispatchEvent(new _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* ChangeEvent */ "a"]("inputChange", this.definition.name, this.value));
      }
    }
  }

  changed(e) {
    this.value.value = e.value;
    this.requestUpdate();

    if (this.definition.name) {
      this.dispatchEvent(new _formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* ChangeEvent */ "a"]("inputChange", this.definition.name, this.value));
    }
  }

}

__decorate([Object(lit_element__WEBPACK_IMPORTED_MODULE_1__[/* property */ "f"])({
  converter: Object
})], SelectableSectionField.prototype, "value", void 0);

Object(_formsey_core__WEBPACK_IMPORTED_MODULE_0__[/* register */ "i"])("formsey-selectable-section", SelectableSectionField, ["native", "vaadin"], "selectableSection", "@formsey/fields-native/SelectableSectionField");

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return unsafeHTML; });
/* harmony import */ var _lib_parts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

 // For each part, remember the value that was last rendered to the part by the
// unsafeHTML directive, and the DocumentFragment that was last set as a value.
// The DocumentFragment is used as a unique key to check if the last value
// rendered to the part was with unsafeHTML. If not, we'll always re-render the
// value passed to unsafeHTML.

const previousValues = new WeakMap();
/**
 * Renders the result as HTML, rather than text.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */

const unsafeHTML = Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_1__[/* directive */ "d"])(value => part => {
  if (!(part instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_1__[/* NodePart */ "b"])) {
    throw new Error('unsafeHTML can only be used in text bindings');
  }

  const previousValue = previousValues.get(part);

  if (previousValue !== undefined && Object(_lib_parts_js__WEBPACK_IMPORTED_MODULE_0__[/* isPrimitive */ "h"])(value) && value === previousValue.value && part.value === previousValue.fragment) {
    return;
  }

  const template = document.createElement('template');
  template.innerHTML = value; // innerHTML casts to string internally

  const fragment = document.importNode(template.content, true);
  part.setValue(fragment);
  previousValues.set(part, {
    value,
    fragment
  });
});

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BooleanField", function() { return /* reexport */ BooleanField_BooleanField; });
__webpack_require__.d(__webpack_exports__, "ButtonField", function() { return /* reexport */ ButtonField_ButtonField; });
__webpack_require__.d(__webpack_exports__, "CheckboxesField", function() { return /* reexport */ CheckboxesField_CheckboxesField; });
__webpack_require__.d(__webpack_exports__, "ColorField", function() { return /* reexport */ ColorField_ColorField; });
__webpack_require__.d(__webpack_exports__, "DateField", function() { return /* reexport */ DateField_DateField; });
__webpack_require__.d(__webpack_exports__, "DateTimeField", function() { return /* reexport */ DateTimeField_DateTimeField; });
__webpack_require__.d(__webpack_exports__, "EmailField", function() { return /* reexport */ EmailField_EmailField; });
__webpack_require__.d(__webpack_exports__, "ImageField", function() { return /* reexport */ ImageField_ImageField; });
__webpack_require__.d(__webpack_exports__, "ImagesField", function() { return /* reexport */ ImagesField_ImagesField; });
__webpack_require__.d(__webpack_exports__, "ListField", function() { return /* reexport */ ListField_ListField; });
__webpack_require__.d(__webpack_exports__, "MarkupField", function() { return /* reexport */ MarkupField_MarkupField; });
__webpack_require__.d(__webpack_exports__, "MonthField", function() { return /* reexport */ MonthField_MonthField; });
__webpack_require__.d(__webpack_exports__, "MultipleChoiceField", function() { return /* reexport */ MultipleChoiceField_MultipleChoiceField; });
__webpack_require__.d(__webpack_exports__, "NestedFormField", function() { return /* reexport */ NestedFormField_NestedFormField; });
__webpack_require__.d(__webpack_exports__, "NumberField", function() { return /* reexport */ NumberField_NumberField; });
__webpack_require__.d(__webpack_exports__, "OptionalSectionField", function() { return /* reexport */ OptionalSectionField["a" /* OptionalSectionField */]; });
__webpack_require__.d(__webpack_exports__, "PasswordField", function() { return /* reexport */ PasswordField_PasswordField; });
__webpack_require__.d(__webpack_exports__, "PhoneField", function() { return /* reexport */ PhoneField_PhoneField; });
__webpack_require__.d(__webpack_exports__, "RepeatingField", function() { return /* reexport */ RepeatingSectionField_RepeatingSectionField; });
__webpack_require__.d(__webpack_exports__, "SearchField", function() { return /* reexport */ SearchField_SearchField; });
__webpack_require__.d(__webpack_exports__, "SectionField", function() { return /* reexport */ SectionField_SectionField; });
__webpack_require__.d(__webpack_exports__, "SelectableSectionField", function() { return /* reexport */ SelectableSectionField["a" /* SelectableSectionField */]; });
__webpack_require__.d(__webpack_exports__, "StringField", function() { return /* reexport */ StringField_StringField; });
__webpack_require__.d(__webpack_exports__, "TextField", function() { return /* reexport */ TextField_TextField; });
__webpack_require__.d(__webpack_exports__, "TimeField", function() { return /* reexport */ TimeField_TimeField; });
__webpack_require__.d(__webpack_exports__, "UploadField", function() { return /* reexport */ UploadField_UploadField; });
__webpack_require__.d(__webpack_exports__, "URLField", function() { return /* reexport */ URLField_URLField; });
__webpack_require__.d(__webpack_exports__, "WeekField", function() { return /* reexport */ WeekField_WeekField; });
__webpack_require__.d(__webpack_exports__, "YouTubeField", function() { return /* reexport */ YouTubeField_YouTubeField; });
__webpack_require__.d(__webpack_exports__, "ICON_FILE", function() { return /* reexport */ ICON_FILE; });
__webpack_require__.d(__webpack_exports__, "ICON_UPLOAD", function() { return /* reexport */ ICON_UPLOAD; });
__webpack_require__.d(__webpack_exports__, "ICON_REMOVE", function() { return /* reexport */ ICON_REMOVE; });
__webpack_require__.d(__webpack_exports__, "ICON_COLOR_FIELD", function() { return /* reexport */ ICON_COLOR_FIELD; });

// EXTERNAL MODULE: ./packages/formsey-core/index.ts + 10 modules
var formsey_core = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/lit-element/lit-element.js + 5 modules
var lit_element = __webpack_require__(0);

// CONCATENATED MODULE: ./packages/formsey-fields-native/BooleanField.ts
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class BooleanField_BooleanField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    return lit_element["e" /* html */]`<label class="bfl"><input id="checkbox" type="checkbox" @click="${this.clicked}" ?checked="${this.value}" ?required="${this.definition.required}">${this.definition.label}</label>`;
  }

  clicked(e) {
    this.value = this.checkbox.checked;
    this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("change", this.definition.name, this.value));
  }

  firstUpdated() {
    this.checkbox.indeterminate = this.definition.indeterminate;
  }

  focusField(path) {
    if (path == this.definition.name) {
      this.checkbox.focus();
    }
  }

}

__decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], BooleanField_BooleanField.prototype, "value", void 0);

__decorate([Object(lit_element["g" /* query */])("#checkbox")], BooleanField_BooleanField.prototype, "checkbox", void 0);

Object(formsey_core["i" /* register */])("formsey-boolean", BooleanField_BooleanField, "native", "boolean", "@formsey/fields-native/BooleanField");
// EXTERNAL MODULE: ./node_modules/lit-html/directives/if-defined.js
var if_defined = __webpack_require__(2);

// CONCATENATED MODULE: ./packages/formsey-fields-native/ButtonField.ts
var ButtonField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class ButtonField_ButtonField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    return lit_element["e" /* html */]`<button class="input" type="${Object(if_defined["a" /* ifDefined */])(this.definition.buttonType)}" @click="${this.clicked}" ?disabled="${this.definition.disabled}">${this.definition.text}</button>`;
  }

  focusField(path) {
    if (path == this.definition.name) {
      this.button.focus();
    }
  }

}

ButtonField_decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], ButtonField_ButtonField.prototype, "value", void 0);

ButtonField_decorate([Object(lit_element["g" /* query */])("button")], ButtonField_ButtonField.prototype, "button", void 0);

Object(formsey_core["i" /* register */])("formsey-button", ButtonField_ButtonField, "native", "button", "@formsey/fields-native/ButtonField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/CheckboxesField.ts
var CheckboxesField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class CheckboxesField_CheckboxesField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    if (!this.value) {
      this.value = [];
    }

    let templates = [];

    if (this.definition.options) {
      for (let i = 0; i < this.definition.options.length; i++) {
        let option = this.definition.options[i];
        let label = option.label ? option.label : option.value;
        let value = option.value ? option.value : option.label;
        let checked = this.value.includes(value);
        templates.push(lit_element["e" /* html */]`<div><label><input type="checkbox" .checked="${checked}" value="${value}" @change="${this.changed}">${label}</label></div>`);
      }
    }

    if (this.definition.other) {
      let other = this.value.filter(value => this.definition.options.filter(option => value == (option.value ? option.value : option.label)).length == 0);
      let checked = other.length > 0;
      templates.push(lit_element["e" /* html */]`<div class="other"><label><input type="checkbox" .checked="${checked}" name="${this.definition.name}" value="__other" @change="${this.changed}">Other</label>${Object(formsey_core["f" /* createField */])(this.components, {
        type: "string",
        "name": "other",
        disabled: this.definition.disabled || !checked
      }, checked ? other[0] : "", this.path(), null, e => this.changed(e), null)}</div>`);
    }

    let customValidity = this.definition.customValidity;

    if (this.error && this.error.validityMessage) {
      customValidity = this.error.validityMessage;
    }

    return lit_element["e" /* html */]`<div class="options">${templates}</div>`;
  }

  otherChanged(e) {
    this.value = e.detail.value;
    this.requestUpdate();

    if (this.definition.name) {
      this.dispatchEvent(new formsey_core["a" /* ChangeEvent */](e.type, this.definition.name, this.value));
    }
  }

  changed(e) {
    let values = [];
    let other = false;

    for (let value of this.values()) {
      if (value == "__other") {
        other = true;
        this.otherTextField.definition.disabled = false;
        values.push(this.otherTextField.value);
        this.otherTextField.requestUpdate();
        this.otherTextField.updateComplete.then(() => {
          this.otherTextField.focusField("other");
        });
      } else {
        values.push(value);
      }
    }

    if (!other && this.otherTextField) {
      this.otherTextField.value = "";
    }

    this.value = values;

    if (this.definition.name) {
      this.dispatchEvent(new formsey_core["a" /* ChangeEvent */](e.type, this.definition.name, this.value));
    }
  }

  values() {
    let values = [];
    this.checkboxes.forEach(checkbox => {
      if (checkbox.checked) {
        values.push(checkbox.value);
      }
    });
    return values;
  }

}

CheckboxesField_decorate([Object(lit_element["g" /* query */])("formsey-string")], CheckboxesField_CheckboxesField.prototype, "otherTextField", void 0);

CheckboxesField_decorate([Object(lit_element["h" /* queryAll */])("input[type=checkbox]")], CheckboxesField_CheckboxesField.prototype, "checkboxes", void 0);

Object(formsey_core["i" /* register */])("formsey-checkboxes", CheckboxesField_CheckboxesField, "native", "checkboxes", "@formsey/fields-native/CheckboxesField");
// EXTERNAL MODULE: ./packages/formsey-core/InvalidEvent.ts
var InvalidEvent = __webpack_require__(5);

// CONCATENATED MODULE: ./packages/formsey-fields-native/styles.ts

const INPUT_STYLE = lit_element["b" /* css */]`
  .input {
    user-select: auto;
    outline: none;
    box-sizing: border-box;
    width: 100%;
    height: var(--formsey-input-height, 2em);
    font-family: var(--formsey-font-family, var(--fs-font-family, inherit));
    font-size: var(--formsey-font-size, var(--fs-font-size, inherit));
    color: var(--formsey-text-color, var(--fs-text-color, inherit));
    font-weight: var(--formsey-font-weight, var(--fs-font-weight, inherit));
    border-radius: var(--formsey-input-border-radius, var(--fs-border-radius, 3px));
    padding: var(--formsey-input-padding, var(--fs-widget-padding, .2em .3em));
    background: var(--formsey-input-background, var(--fs-widget-background-color-alpha, #99999920));
    border: var(--formsey-input-border, 1px solid transparent);
    transition: border 0.12s ease-out;
  }
  .input:focus-within {
    border: 1px solid var(--formsey-border-color-focus, var(--fs-border-color-focus, #020b2f));
  }`;
const NESTED_FORM_STYLE = lit_element["b" /* css */]`
  ::part(title) {
      font-size: var(--formsey-title-font-size, larger);
      font-family: var(--formsey-title-font-family, var(--formsey-font-family, inherit));
      font-weight: var(--formsey-title-font-weight, inherit);
      line-height: var(--formsey-title-line-height, inherit);
      color: var(--formsey-title-color, inherit);
      margin: var(--formsey-title-margin, var(--fs-padding, 12px 0 4px 0));
    }

  ::part(description) {
    font-size: var(--formsey-description-font-size, inherit);
    font-family: var(--formsey-description-font-family, var(--formsey-font-family, inherit));
    font-weight: var(--formsey-description-font-weight, inherit);
    line-height: var(--formsey-description-line-height, inherit);
    color: var(--formsey-description-color, #757c98);
    margin: var(--formsey-description-margin, var(--fs-padding, 12px 0 4px 0));
  }`;
// CONCATENATED MODULE: ./packages/formsey-fields-native/InputField.ts
var InputField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class InputField_InputField extends formsey_core["d" /* LabeledField */] {
  set definition(definition) {
    this.autofocus = definition.autofocus;
    this._definition = definition;
  }

  get definition() {
    return this._definition;
  }

  static get styles() {
    return [...super.styles, INPUT_STYLE];
  }

  formResetCallback() {
    this.value = '';
  }

  renderField() {
    return lit_element["e" /* html */]`<input id="input" class="input" type="${this.type}" ?autofocus=${this.definition.autofocus} ?readonly=${this.definition.readonly} ?disabled=${this.definition.disabled} ?required="${this.definition.required}" @input="${this.inputted}" @change="${this.changed}" @blur="${this.blurred}" @focus="${this.focused}" @invalid="${this.invalid}" name="${this.path()}" placeholder="${Object(if_defined["a" /* ifDefined */])(this.definition.placeholder)}" autocomplete="${Object(if_defined["a" /* ifDefined */])(this.definition.autocomplete)}" pattern="${Object(if_defined["a" /* ifDefined */])(this.definition.pattern)}" minlength="${Object(if_defined["a" /* ifDefined */])(this.definition.minlength)}" maxlength="${Object(if_defined["a" /* ifDefined */])(this.definition.maxlength)}"  min="${Object(if_defined["a" /* ifDefined */])(this.definition.min)}" max="${Object(if_defined["a" /* ifDefined */])(this.definition.max)}" step="${Object(if_defined["a" /* ifDefined */])(this.definition.step)}" .value="${this.value ? this.value : ''}">`;
  }

  focusField(path) {
    if (path == this.definition.name) {
      this.input.focus();
    }
  }

  focus() {
    this.input.focus();
  }

  validate(report) {
    this.input.setCustomValidity("");
    return this.input.checkValidity();
  }

  invalid() {
    let validityState = {};

    for (let key in this.input.validity) {
      if (this.input.validity[key]) {
        validityState[key] = this.input.validity[key];
      }
    }

    if (this.definition.customValidity && !this.input.validity.valid) {
      this.input.setCustomValidity(this.definition.customValidity);
    }

    this.errors[this.definition.name] = this.error ? this.error : new InvalidEvent["a" /* InvalidError */](this.input.validationMessage, false, validityState);
    this.dispatchEvent(new InvalidEvent["b" /* InvalidEvent */](this.errors));
  }

  get type() {
    return "text";
  }

}

InputField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], InputField_InputField.prototype, "definition", null);

InputField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], InputField_InputField.prototype, "value", void 0);

InputField_decorate([Object(lit_element["f" /* property */])({
  type: Boolean,
  reflect: true
})], InputField_InputField.prototype, "autofocus", void 0);

InputField_decorate([Object(lit_element["g" /* query */])("#input")], InputField_InputField.prototype, "input", void 0);
// CONCATENATED MODULE: ./packages/formsey-fields-native/StringField.ts


class StringField_StringField extends InputField_InputField {
  get type() {
    return "text";
  }

  firstUpdated() {
    var _a;

    if ((_a = this.definition) === null || _a === void 0 ? void 0 : _a.autoselect) {
      this.input.addEventListener('focus', e => this.input.select());
    }
  }

}
Object(formsey_core["i" /* register */])("formsey-string", StringField_StringField, "native", "string", "@formsey/fields-native/StringField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/ColorField.ts
var ColorField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





const ICON_COLOR_FIELD = lit_element["e" /* html */]`<svg viewBox="2 2 20 20"><title>Color</title><path d="M17.484 12q.609 0 1.055-.422t.445-1.078-.445-1.078-1.055-.422-1.055.422-.445 1.078.445 1.078 1.055.422zM14.484 8.016q.609 0 1.055-.445t.445-1.055-.445-1.055-1.055-.445-1.055.445-.445 1.055.445 1.055 1.055.445zM9.516 8.016q.609 0 1.055-.445t.445-1.055-.445-1.055-1.055-.445-1.055.445-.445 1.055.445 1.055 1.055.445zM6.516 12q.609 0 1.055-.422t.445-1.078-.445-1.078-1.055-.422-1.055.422-.445 1.078.445 1.078 1.055.422zM12 3q3.703 0 6.352 2.344t2.648 5.672q0 2.063-1.477 3.516t-3.539 1.453h-1.734q-.656 0-1.078.445t-.422 1.055q0 .516.375 .984t.375 1.031q0 .656-.422 1.078t-1.078.422q-3.75 0-6.375-2.625t-2.625-6.375 2.625-6.375 6.375-2.625z"></path></svg>`;
class ColorField_ColorField extends StringField_StringField {
  renderField() {
    this.definition.maxlength = 9;
    return lit_element["e" /* html */]`<div class="cf" @keydown="${this.keyDown}">${super.renderField()}<div class="cfp" style="background-color:${Object(if_defined["a" /* ifDefined */])(this.value)}">${!this.value ? ICON_COLOR_FIELD : undefined}<input type="color" value="${this.value ? this.value : "#ff0000"}" @input="${this.changed}" tabindex="-1"></div></div>`;
  }

  get type() {
    return "text";
  }

  keyDown(e) {
    if (e.keyCode == 13) {
      e.stopPropagation();
      this.color.click();
    }
  }

}

ColorField_decorate([Object(lit_element["g" /* query */])("input[type='color']")], ColorField_ColorField.prototype, "color", void 0);

Object(formsey_core["i" /* register */])("formsey-color", ColorField_ColorField, "native", "color", "@formsey/fields-native/ColorField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/DateField.ts


class DateField_DateField extends InputField_InputField {
  get type() {
    return "date";
  }

}
Object(formsey_core["i" /* register */])("formsey-date", DateField_DateField, "native", "date", "@formsey/fields-native/DateField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/DateTimeField.ts


class DateTimeField_DateTimeField extends DateField_DateField {
  get type() {
    return "datetime-local";
  }

}
Object(formsey_core["i" /* register */])("formsey-datetime", DateTimeField_DateTimeField, "native", "datetime", "@formsey/fields-native/DateTimeField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/EmailField.ts


class EmailField_EmailField extends StringField_StringField {
  get type() {
    return "email";
  }

}
Object(formsey_core["i" /* register */])("formsey-email", EmailField_EmailField, "native", "email", "@formsey/fields-native/EmailField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/ImageField.ts
var ImageField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class ImageField_ImageField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    return lit_element["e" /* html */]`<div class="if" style="text-align: ${this.definition.align}"><img src="${this.definition.url}" title="${this.definition.label}" style="width: ${this.definition.width}"></div>`;
  }

}

ImageField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], ImageField_ImageField.prototype, "definition", void 0);

Object(formsey_core["i" /* register */])("formsey-image", ImageField_ImageField, ["native", "material", "vaadin"], "image", "@formsey/fields-native/ImageField");
// CONCATENATED MODULE: ./node_modules/@floreysoft/utils/Utils.js
const KEYCODE = {
  DOWN: 40,
  LEFT: 37,
  RIGHT: 39,
  UP: 38,
  SPACE: 32,
  RETURN: 13,
  ESCAPE: 27,
  CUT: 88,
  COPY: 67,
  PASTE: 86
};
function register(tag, constructor) {
  if (customElements.get(tag)) {
    console.log("'" + tag + "' already exists, skipping...");
  } else {
    customElements.define(tag, constructor);
  }
}
function walkAndFocus(start, directions) {
  let end = walk(start, directions);

  if (end) {
    end.focus();
  }

  return end;
}
function walk(start, directions) {
  let end = start;

  if (directions) {
    for (const c of directions) {
      switch (c) {
        case 'p':
          end = end.parentElement;
          break;

        case 'c':
          end = end.firstElementChild;
          break;

        case 'r':
          end = end.nextElementSibling;
          break;

        case 'l':
          end = end.previousElementSibling;
          break;
      }

      if (!end) {
        return undefined;
      }
    }
  }

  return end;
}
function closestElement(selector, base) {
  function __closestFrom(el) {
    if (!el || el === document || el === window) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    let found = el.closest(selector);
    return found ? found : __closestFrom(el.getRootNode().host);
  }

  return __closestFrom(base);
}
// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__(15);

// CONCATENATED MODULE: ./packages/formsey-fields-native/ImagesField.ts
var ImagesField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class ImagesField_ImageCheckbox extends lit_element["a" /* LitElement */] {
  render() {
    return lit_element["e" /* html */]`<input id="${this.path}.${this.id}.cb" tabindex="${this.tabIndex}" type="checkbox" @keydown="${this.keyDown}" @change="${this.changed}" ?checked="${this.checked}" ?disabled="${this.disabled}" ?required="${this.required}"><label for="${this.path}.${this.id}.cb"><img src="${this.src}" alt="${this.alt}"/>${Object(if_defined["a" /* ifDefined */])(this.label)}</label>`;
  }

  createRenderRoot() {
    return this;
  }

  updated() {
    this.checkbox.checked = this.checked;
  }

  focus() {
    this.checkbox.focus();
  }

  changed(e) {
    e.stopPropagation();
    this.checked = e.target.checked;
    this.dispatchEvent(new formsey_core["a" /* ChangeEvent */](e.type, this.id, this.checkbox.checked));
  }

  keyDown(e) {
    switch (e.keyCode) {
      case KEYCODE.RETURN:
        this.checkbox.checked = !this.checkbox.checked;
        this.changed(e);
        break;
    }
  }

}

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], ImagesField_ImageCheckbox.prototype, "required", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], ImagesField_ImageCheckbox.prototype, "disabled", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Boolean
})], ImagesField_ImageCheckbox.prototype, "checked", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], ImagesField_ImageCheckbox.prototype, "src", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], ImagesField_ImageCheckbox.prototype, "alt", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], ImagesField_ImageCheckbox.prototype, "label", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], ImagesField_ImageCheckbox.prototype, "path", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Number
})], ImagesField_ImageCheckbox.prototype, "tabIndex", void 0);

ImagesField_decorate([Object(lit_element["g" /* query */])("input[type='checkbox']")], ImagesField_ImageCheckbox.prototype, "checkbox", void 0);

Object(formsey_core["i" /* register */])("formsey-image-checkbox", ImagesField_ImageCheckbox);
class ImagesField_ImagesField extends formsey_core["d" /* LabeledField */] {
  constructor() {
    super();
    this.columns = 5;
    this.ro = new ResizeObserver_es["a" /* default */]((entries, observer) => {
      for (const entry of entries) {
        this.calculateColumns(entry.contentRect.width);
      }
    });
  }

  set definition(definition) {
    this._definition = definition;

    if (this.images) {
      this.calculateColumns(this.images.offsetWidth);
    }
  }

  get definition() {
    return this._definition;
  }

  renderField() {
    if (!this.value) {
      this.value = [];
    }

    let templates = [];

    if (this.definition.images) {
      for (let i = 0; i < this.definition.images.length; i++) {
        const image = this.definition.images[i];
        const value = typeof image.value !== "undefined" ? image.value : image.label;
        const checked = this.definition.multiple ? this.value.includes(value) : this.value === value;
        templates.push(lit_element["e" /* html */]`<formsey-image-checkbox @keydown="${this.keyDown}" path="${this.path()}" id="${value}" ?checked="${checked}" @change="${this.changed}" src="${image.src}" alt="${image.alt}" label="${image.label}" .tabIndex="${i == 0 ? 0 : -1}"></formsey-image-checkbox>`);
      }
    }

    let customValidity = this.definition.customValidity;

    if (this.error && this.error.validityMessage) {
      customValidity = this.error.validityMessage;
    }

    return lit_element["e" /* html */]`<div class="ifi" style="columns:${this.columns} auto">${templates}</div>`;
  }

  firstUpdated() {
    this.ro.observe(this.images);
  }

  focusField(path) {
    if (path == this.definition.name) {}
  }

  changed(e) {
    if (e.detail) {
      if (this.definition.multiple) {
        let value = [];
        this.checkboxes.forEach(checkbox => {
          if (checkbox.checked) {
            value.push(this.extractValue(checkbox.id));
          }
        });
        this.value = value;
      } else {
        this.value = e.detail.value ? this.extractValue(e.detail.name) : undefined;
      }

      if (this.definition.name) {
        this.dispatchEvent(new formsey_core["a" /* ChangeEvent */](e.type, this.definition.name, this.value));
      }
    }
  }

  extractValue(value) {
    let path = value.split('.');
    return path[path.length - 1];
  }

  keyDown(e) {
    if (!e.ctrlKey && !e.altKey) {
      const left = e.currentTarget.getBoundingClientRect().left;
      const top = e.currentTarget.getBoundingClientRect().top;
      const height = e.currentTarget.getBoundingClientRect().height;

      switch (e.keyCode) {
        case KEYCODE.LEFT:
          e.stopPropagation();
          let onTheLeft = this.shadowRoot.elementFromPoint(left - 10, top + height / 2);

          if (onTheLeft) {
            onTheLeft.focus();
          } else {
            this.dispatchEvent(new CustomEvent('focusLeft', {
              bubbles: true,
              composed: true
            }));
          }

          break;

        case KEYCODE.RIGHT:
          e.stopPropagation();
          let onTheRight = this.shadowRoot.elementFromPoint(left + this.columnWidth + 10, top + height / 2);

          if (onTheRight) {
            onTheRight.focus();
          } else {
            this.dispatchEvent(new CustomEvent('focusRight', {
              bubbles: true,
              composed: true
            }));
          }

          break;

        case KEYCODE.UP:
          e.stopPropagation();
          e.preventDefault();

          if (!walkAndFocus(e.currentTarget, "l")) {
            this.dispatchEvent(new CustomEvent('focusAbove', {
              bubbles: true,
              composed: true
            }));
          }

          break;

        case KEYCODE.DOWN:
          e.stopPropagation();
          e.preventDefault();

          if (!walkAndFocus(e.currentTarget, "r")) {
            this.dispatchEvent(new CustomEvent('focusBelow', {
              bubbles: true,
              composed: true
            }));
          }

          break;
      }
    }
  }

  calculateColumns(availableWidth) {
    var _a, _b, _c, _d, _e, _f;

    const columnWidth = ((_a = this.definition) === null || _a === void 0 ? void 0 : _a.columnWidth) ? (_b = this.definition) === null || _b === void 0 ? void 0 : _b.columnWidth : 150;
    const minColumns = ((_c = this.definition) === null || _c === void 0 ? void 0 : _c.minColumns) ? (_d = this.definition) === null || _d === void 0 ? void 0 : _d.minColumns : 1;
    const maxColumns = ((_e = this.definition) === null || _e === void 0 ? void 0 : _e.maxColumns) ? (_f = this.definition) === null || _f === void 0 ? void 0 : _f.maxColumns : 4;
    let columns = Math.round(availableWidth / columnWidth);
    columns = Math.min(columns, maxColumns);
    columns = Math.max(columns, minColumns);
    this.columnWidth = availableWidth / columns;
    this.columns = columns;
  }

}

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Object
})], ImagesField_ImagesField.prototype, "definition", null);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Array
})], ImagesField_ImagesField.prototype, "value", void 0);

ImagesField_decorate([Object(lit_element["f" /* property */])({
  type: Number
})], ImagesField_ImagesField.prototype, "columns", void 0);

ImagesField_decorate([Object(lit_element["h" /* queryAll */])("formsey-image-checkbox")], ImagesField_ImagesField.prototype, "checkboxes", void 0);

ImagesField_decorate([Object(lit_element["g" /* query */])(".ifi")], ImagesField_ImagesField.prototype, "images", void 0);

Object(formsey_core["i" /* register */])("formsey-images", ImagesField_ImagesField, ["native", "material", "vaadin"], "images", "@formsey/fields-native/ImagesField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/ListField.ts
var ListField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class ListField_ListField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    return lit_element["e" /* html */]`
    <select class="input" ?autofocus="${this.definition.autofocus}" ?required="${this.definition.required}" @change="${this.changed}" name="${this.definition.name}" ?disabled="${this.definition.disabled}" .value="${this.value}">
    ${this.definition.options.map(item => lit_element["e" /* html */]`<option ?selected="${item.value ? item.value == this.value : item.label == this.value}" value="${item.value ? item.value : item.label}">${item.label ? item.label : item.value}</option>`)}
    </select>`;
  }

  focusField(path) {
    if (path == this.definition.name) {
      this.selectBox.focus();
    }
  }

  changed(e) {
    this.value = e.currentTarget.value;

    if (this.definition.name) {
      this.dispatchEvent(new formsey_core["a" /* ChangeEvent */](e.type, this.definition.name, this.value));
    }
  }

}

ListField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], ListField_ListField.prototype, "value", void 0);

ListField_decorate([Object(lit_element["g" /* query */])("select")], ListField_ListField.prototype, "selectBox", void 0);

Object(formsey_core["i" /* register */])("formsey-list", ListField_ListField, "native", "list", "@formsey/fields-native/ListField");
// EXTERNAL MODULE: ./node_modules/lit-html/directives/unsafe-html.js
var unsafe_html = __webpack_require__(20);

// CONCATENATED MODULE: ./packages/formsey-fields-native/MarkupField.ts
var MarkupField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class MarkupField_MarkupField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    return lit_element["e" /* html */]`${Object(unsafe_html["a" /* unsafeHTML */])(this.definition.default ? this.definition.default : "")}`;
  }

}

MarkupField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], MarkupField_MarkupField.prototype, "definition", void 0);

Object(formsey_core["i" /* register */])("formsey-markup", MarkupField_MarkupField, ["native", "vaadin", "material"], "markup", "@formsey/fields-native/MarkupField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/MonthField.ts


class MonthField_MonthField extends DateField_DateField {
  get type() {
    return "month";
  }

}
Object(formsey_core["i" /* register */])("formsey-month", MonthField_MonthField, "native", "month", "@formsey/fields-native/MonthField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/MultipleChoiceField.ts
var MultipleChoiceField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class MultipleChoiceField_MultipleChoiceField extends formsey_core["d" /* LabeledField */] {
  renderField() {
    let templates = [];

    if (this.definition.options) {
      for (let i = 0; i < this.definition.options.length; i++) {
        let option = this.definition.options[i];
        let label = option.label ? option.label : option.value;
        let value = option.value ? option.value : option.label;
        let checked = this.value == value;
        templates.push(lit_element["e" /* html */]`<div><label><input type="radio" .checked="${checked}" name="${this.definition.name}" value="${value}" @change="${this.changed}">${label}</label></div>`);
      }
    }

    if (this.definition.other) {
      let checked = this.definition.options.filter(option => this.value == (option.value ? option.value : option.label)).length == 0;
      templates.push(lit_element["e" /* html */]`<div class="other"><label><input type="radio" .checked="${checked}" name="${this.definition.name}" value="__other" @change="${this.changed}">Other</label>${Object(formsey_core["f" /* createField */])(this.components, {
        type: "string",
        "name": "other",
        disabled: this.definition.disabled || !checked
      }, checked ? this.value : "", this.path(), null, e => this.otherChanged(e), null)}</div>`);
    }

    let customValidity = this.definition.customValidity;

    if (this.error && this.error.validityMessage) {
      customValidity = this.error.validityMessage;
    }

    return lit_element["e" /* html */]`<div class="options">${templates}</div>`;
  }

  otherChanged(e) {
    this.value = e.detail.value;
    this.requestUpdate();

    if (this.definition.name) {
      this.dispatchEvent(new formsey_core["a" /* ChangeEvent */](e.type, this.definition.name, this.value));
    }
  }

  changed(e) {
    let value = e.target.value;
    let other = false;

    if (value == "__other") {
      other = true;
      this.otherTextField.definition.disabled = false;
      this.value = this.otherTextField.value;
      this.otherTextField.requestUpdate();
      this.otherTextField.updateComplete.then(() => {
        this.otherTextField.focusField("other");
      });
    } else {
      this.value = value;
    }

    if (!other && this.otherTextField) {
      this.otherTextField.value = "";
      this.otherTextField.definition.disabled = true;
      this.otherTextField.requestUpdate();
    }

    if (this.definition.name) {
      this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("inputChange", this.definition.name, this.value));
    }
  }

}

MultipleChoiceField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], MultipleChoiceField_MultipleChoiceField.prototype, "value", void 0);

MultipleChoiceField_decorate([Object(lit_element["g" /* query */])("formsey-string")], MultipleChoiceField_MultipleChoiceField.prototype, "otherTextField", void 0);

Object(formsey_core["i" /* register */])("formsey-multiple-choice", MultipleChoiceField_MultipleChoiceField, "native", "multipleChoice", "@formsey/fields-native/MultipleChoiceField");
// EXTERNAL MODULE: ./packages/formsey-core/NestedFormField.ts
var formsey_core_NestedFormField = __webpack_require__(16);

// CONCATENATED MODULE: ./packages/formsey-fields-native/NestedFormField.ts



class NestedFormField_NestedFormField extends formsey_core_NestedFormField["a" /* NestedFormField */] {
  static get styles() {
    return [...super.styles, NESTED_FORM_STYLE];
  }

}
Object(formsey_core["i" /* register */])("formsey-nested-form", NestedFormField_NestedFormField, ["material", "native", "vaadin"], "nestedLayout", "@formsey/fields-native/NestedFormField");
Object(formsey_core["i" /* register */])("formsey-nested-form", NestedFormField_NestedFormField, ["material", "native", "vaadin"], "nestedForm", "@formsey/fields-native/NestedFormField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/NumberField.ts


class NumberField_NumberField extends InputField_InputField {
  get type() {
    return "number";
  }

}
Object(formsey_core["i" /* register */])("formsey-number", NumberField_NumberField, "native", "number", "@formsey/fields-native/NumberField");
// EXTERNAL MODULE: ./packages/formsey-fields-native/OptionalSectionField.ts
var OptionalSectionField = __webpack_require__(17);

// CONCATENATED MODULE: ./packages/formsey-fields-native/PasswordField.ts


class PasswordField_PasswordField extends StringField_StringField {
  get type() {
    return "password";
  }

}
Object(formsey_core["i" /* register */])("formsey-password", PasswordField_PasswordField, "native", "password", "@formsey/fields-native/PasswordField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/PhoneField.ts


class PhoneField_PhoneField extends StringField_StringField {
  get type() {
    return "tel";
  }

}
Object(formsey_core["i" /* register */])("formsey-phone", PhoneField_PhoneField, "native", "phone", "@formsey/fields-native/PhoneField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/RepeatingSectionField.ts
var RepeatingSectionField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




const ICON_MINUS = lit_element["e" /* html */]`<svg viewBox="0 0 24 24"><title>Remove section</title><path d="M5 13h14c0.552 0 1-0.448 1-1s-0.448-1-1-1h-14c-0.552 0-1 0.448-1 1s0.448 1 1 1z"></path></svg>`;
const ICON_PLUS = lit_element["e" /* html */]`<svg viewBox="0 0 24 24"><title>Add section</title><path d="M5 13h6v6c0 0.552 0.448 1 1 1s1-0.448 1-1v-6h6c0.552 0 1-0.448 1-1s-0.448-1-1-1h-6v-6c0-0.552-0.448-1-1-1s-1 0.448-1 1v6h-6c-0.552 0-1 0.448-1 1s0.448 1 1 1z"></path></svg>`;
class RepeatingSectionField_RepeatingSectionField extends formsey_core["d" /* LabeledField */] {
  constructor() {
    super(...arguments);
    this.value = [];
  }

  renderField() {
    if (!this.value) {
      this.value = [];

      if (this.definition.min) {
        for (let i = 0; i < this.definition.min; i++) {
          this.value.push({});
        }
      }
    }

    const itemTemplates = [];

    if (this.value) {
      for (let i = 0; i < this.value.length; i++) {
        const value = this.value[i];
        let fieldErrors = {};

        if (this.errors) {
          for (let error in this.errors) {
            let path = this.definition.name + "[" + i + "].";

            if (this.definition.name && error.startsWith(path)) {
              fieldErrors[error.substring(path.length)] = this.errors[error];
            }
          }
        }

        const template = lit_element["e" /* html */]`<div class="form" draggable="true" @drop="${e => this.drop(e, i)}" @dragover="${e => this.allowDrop(e, i)}" @dragstart="${e => this.drag(e, i)}">
        ${this.value.length > this.definition.min ? lit_element["e" /* html */]`<div class="fs-remove-wrapper"><button class="fs-remove"  tabindex="0" @click="${e => this.removeForm(i)}">${ICON_MINUS}</button></div>` : undefined}
        ${Object(formsey_core["f" /* createField */])(this.components, { ...this.definition.form,
          name: ""
        }, value, this.path() + "[" + i + "]", fieldErrors, event => this.changed(event), event => this.invalid(event))}</div>`;
        itemTemplates.push(template);
      }
    }

    return lit_element["e" /* html */]`<div id='fs-repeat'>${itemTemplates}</div>${this.value.length < this.definition.max ? lit_element["e" /* html */]`<button  tabindex="0" @click="${e => this.addForm()}" class="fs-add">${ICON_PLUS}</button>` : undefined}`;
  }

  focusField(path) {
    var _a;

    let index;

    if (path.startsWith(this.definition.name + "[")) {
      index = path.substring(this.definition.name.length + 1, path.indexOf(']'));
      path = path.substring(path.indexOf(']') + 1);
    }

    let i = 0;

    for (let field of this._fields) {
      if (index == i) {
        let child = field.firstElementChild;

        if (child && path.startsWith((_a = child.definition) === null || _a === void 0 ? void 0 : _a.name) && typeof child['focusField'] == "function") {
          child.focusField(path);
        }
      }

      i++;
    }
  }

  validate(report) {
    for (let field of this._fields) {
      let child = field.firstElementChild;

      if (report) {
        child.reportValidity();
      } else {
        child.checkValidity();
      }
    }

    return true;
  }

  addForm() {
    this.value.push({});
    this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("inputChange", this.definition.name, this.value));
    this.requestUpdate();
  }

  removeForm(index) {
    this.value.splice(index, 1);
    this.requestUpdate();
    this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("inputChange", this.definition.name, this.value));
  }

  drag(e, from) {// e.dataTransfer.setData("text", "move="+from);
  }

  allowDrop(e, index) {// e.preventDefault();
  }

  drop(e, to) {
    /*
    let from = e.dataTransfer.getData("text");
    if (from.indexOf('move=')==0 && from.substring(5) != to) {
      let tmp = this.value[from];
      this.value[from] = this.value[to];
      this.value[to] = tmp;
      if (this.definition.name) {
        this.dispatchEvent(new ChangeEvent(this.definition.name, this.value));
      }
      this.requestUpdate();
    }
    */
  }

  changed(e) {
    let path = e.detail.name.split('.');
    let index = path.shift();
    index = index.substring(1, index.length - 1);
    this.value[+index] = e.detail.value;

    if (this.definition.name) {
      this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("inputChange", this.definition.name + "[" + index + "]." + path.shift(), this.value));
    }
  }

  invalid(e) {
    e.stopPropagation();

    for (let error in e.errors) {
      let index = error.indexOf('.');
      this.errors[this.definition.name + "[" + error.substring(0, index) + "]." + error.substring(index + 1)] = e.errors[error];
    }

    this.dispatchEvent(new InvalidEvent["b" /* InvalidEvent */](this.errors));
  }

}

RepeatingSectionField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], RepeatingSectionField_RepeatingSectionField.prototype, "value", void 0);

RepeatingSectionField_decorate([Object(lit_element["h" /* queryAll */])(".form")], RepeatingSectionField_RepeatingSectionField.prototype, "_fields", void 0);

Object(formsey_core["i" /* register */])("formsey-repeating-section", RepeatingSectionField_RepeatingSectionField, ["native", "material", "vaadin"], "repeatingSection", "@formsey/fields-native/RepeatingSectionField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/SearchField.ts


class SearchField_SearchField extends StringField_StringField {
  get type() {
    return "search";
  }

}
Object(formsey_core["i" /* register */])("formsey-search", SearchField_SearchField, "native", "search", "@formsey/fields-native/SearchField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/SectionField.ts
var SectionField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class SectionField_SectionField extends formsey_core["b" /* Field */] {
  renderField() {
    return lit_element["e" /* html */]`<header>${Object(if_defined["a" /* ifDefined */])(this.definition.label)}</header><footer>${Object(if_defined["a" /* ifDefined */])(this.definition.helpText)}</footer>`;
  }

}

SectionField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], SectionField_SectionField.prototype, "definition", void 0);

Object(formsey_core["i" /* register */])("formsey-section", SectionField_SectionField, ["native", "vaadin"], "section", "@formsey/fields-native/SectionField");
// EXTERNAL MODULE: ./packages/formsey-fields-native/SelectableSectionField.ts
var SelectableSectionField = __webpack_require__(19);

// CONCATENATED MODULE: ./packages/formsey-fields-native/TextField.ts
var TextField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class TextField_TextField extends formsey_core["d" /* LabeledField */] {
  formResetCallback() {
    this.value = '';
  }

  renderField() {
    return lit_element["e" /* html */]`<textarea class="input" rows="3" ?autofocus=${this.definition.autofocus} ?disabled=${this.definition.disabled} ?required="${this.definition.required}" @input="${this.inputted}" @change="${this.changed}" @invalid="${this.invalid}" name="${this.definition.name}" placeholder="${Object(if_defined["a" /* ifDefined */])(this.definition.placeholder)}" autocomplete="${this.definition.autocomplete}" pattern="${Object(if_defined["a" /* ifDefined */])(this.definition.pattern)}" minlength="${Object(if_defined["a" /* ifDefined */])(this.definition.minlength)}" maxlength="${Object(if_defined["a" /* ifDefined */])(this.definition.maxlength)}"  min="${Object(if_defined["a" /* ifDefined */])(this.definition.min)}" max="${Object(if_defined["a" /* ifDefined */])(this.definition.max)}" step="${Object(if_defined["a" /* ifDefined */])(this.definition.step)}" .value="${this.value || ''}"></textarea>`;
  }

  focusField(path) {
    if (path == this.definition.name) {
      this.textArea.focus();
    }
  }

  validate(report) {
    this.textArea.setCustomValidity("");
    return this.textArea.checkValidity();
  }

  invalid() {
    let validityState = {};

    for (let key in this.textArea.validity) {
      if (this.textArea.validity[key]) {
        validityState[key] = this.textArea.validity[key];
      }
    }

    if (this.definition.customValidity && !this.textArea.validity.valid) {
      this.textArea.setCustomValidity(this.definition.customValidity);
    }

    this.errors[this.definition.name] = this.error ? this.error : new InvalidEvent["a" /* InvalidError */](this.textArea.validationMessage, false, validityState);
    this.dispatchEvent(new InvalidEvent["b" /* InvalidEvent */](this.errors));
  }

}

TextField_decorate([Object(lit_element["f" /* property */])({
  type: String
})], TextField_TextField.prototype, "value", void 0);

TextField_decorate([Object(lit_element["g" /* query */])("textarea")], TextField_TextField.prototype, "textArea", void 0);

Object(formsey_core["i" /* register */])("formsey-text", TextField_TextField, "native", "text", "@formsey/fields-native/TextField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/TimeField.ts


class TimeField_TimeField extends DateField_DateField {
  get type() {
    return "time";
  }

}
Object(formsey_core["i" /* register */])("formsey-time", TimeField_TimeField, "native", "time", "@formsey/fields-native/TimeField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/UploadField.ts
var UploadField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




let ICON_FILE = lit_element["e" /* html */]`<svg viewBox="0 0 32 32"><path d="M28.681 7.159c-0.694-0.947-1.662-2.053-2.724-3.116s-2.169-2.030-3.116-2.724c-1.612-1.182-2.393-1.319-2.841-1.319h-15.5c-1.378 0-2.5 1.121-2.5 2.5v27c0 1.378 1.122 2.5 2.5 2.5h23c1.378 0 2.5-1.122 2.5-2.5v-19.5c0-0.448-0.137-1.23-1.319-2.841zM24.543 5.457c0.959 0.959 1.712 1.825 2.268 2.543h-4.811v-4.811c0.718 0.556 1.584 1.309 2.543 2.268zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-23c-0.271 0-0.5-0.229-0.5-0.5v-27c0-0.271 0.229-0.5 0.5-0.5 0 0 15.499-0 15.5 0v7c0 0.552 0.448 1 1 1h7v19.5z"></path></svg>`;
let ICON_UPLOAD = lit_element["e" /* html */]`<svg viewBox="0 0 24 24"><path d="M8 12h4v-6h3l-5-5-5 5h3v6zM19.338 13.532c-0.21-0.224-1.611-1.723-2.011-2.114-0.265-0.259-0.644-0.418-1.042-0.418h-1.757l3.064 2.994h-3.544c-0.102 0-0.194 0.052-0.24 0.133l-0.816 1.873h-5.984l-0.816-1.873c-0.046-0.081-0.139-0.133-0.24-0.133h-3.544l3.063-2.994h-1.756c-0.397 0-0.776 0.159-1.042 0.418-0.4 0.392-1.801 1.891-2.011 2.114-0.489 0.521-0.758 0.936-0.63 1.449l0.561 3.074c0.128 0.514 0.691 0.936 1.252 0.936h16.312c0.561 0 1.124-0.422 1.252-0.936l0.561-3.074c0.126-0.513-0.142-0.928-0.632-1.449z"></path></svg>`;
const ICON_REMOVE = lit_element["e" /* html */]`<svg viewBox="0 0 32 32"><title>Clear</title><path d="M20 4v-4h-8v4h-8v4h24v-4zM24 10v16h-4v-16h-2v16h-4v-16h-2v16h-4v-16h-2v17c0 2 1 3 3 3h14c2 0 3-1 3-3v-17h-2z"></path></svg>`;
class UploadField_UploadField extends formsey_core["d" /* LabeledField */] {
  constructor() {
    super(...arguments);
    this.messages = {
      prompt: "Click to pick or drop file(s)"
    };
  }

  renderField() {
    if (!this.value) {
      this.value = [];
    }

    return lit_element["e" /* html */]`<div class="input">${!this.definition.multiple && this.value.length > 0 ? undefined : lit_element["e" /* html */]`<label @dragover="${this.dragOver}" @dragenter="${this.dragEnter}" @dragleave="${this.dragLeave}" @drop="${this.drop}"><input type="file" ?multiple="${this.definition.multiple}" capture="${Object(if_defined["a" /* ifDefined */])(this.definition.capture)}" accept="${this.definition.accept ? this.definition.accept.join(',') : ''}" @change="${e => this.handleFiles(Array.from(this.input.files))}" tabindex="0" id="file"><div class="prompt"><span>${this.messages.prompt}</span>${ICON_UPLOAD}</div></label>`}
    ${this.value.length > 0 ? lit_element["e" /* html */]`<div class="files">
    ${this.value.map(file => {
      const aMultiples = ["kb", "mb", "gb", "tb"];
      let niceSize;

      for (let nMultiple = 0, nApprox = file.size / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
        niceSize = nApprox.toFixed(3) + " " + aMultiples[nMultiple];
      }

      let preview;
      file.type.startsWith("image/") ? preview = lit_element["e" /* html */]`<img class="preview" src="${file['data']}">` : preview = ICON_FILE;
      return lit_element["e" /* html */]`${preview}<div class="filename" title="${file.name}">${file.name}</div><div>${niceSize}</div><div tabindex="0" class="remove" @click="${e => {
        this.removeFile(file.name);
      }}">${ICON_REMOVE}</div>`;
    })}
    </div>` : undefined}</div>`;
  }

  dragOver(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  dragEnter(e) {
    e.preventDefault();
    e.stopPropagation();
    this.label.classList.add("over");
  }

  dragLeave(e) {
    e.preventDefault();
    e.stopPropagation();
    this.label.classList.remove("over");
  }

  drop(e) {
    e.preventDefault();
    e.stopPropagation();
    let dt = e.dataTransfer;
    let files = [...dt.files];
    this.handleFiles(files);
  }

  removeFile(name) {
    this.value = this.value.filter(file => file.name != name);
    this.requestUpdate();
    this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("inputChange", this.definition.name, this.value));
  }

  handleFiles(files) {
    files.forEach(file => {
      let reader = new FileReader();
      reader.addEventListener("load", () => {
        this.value.push({
          data: reader.result,
          name: file.name,
          type: file.type,
          size: file.size
        });
        this.dispatchEvent(new formsey_core["a" /* ChangeEvent */]("inputChange", this.definition.name, this.value));
        this.requestUpdate();
      }, false);
      reader.readAsDataURL(file);
    });
  }

}
UploadField_UploadField.formAssociated = true;

UploadField_decorate([Object(lit_element["f" /* property */])({
  type: Object
})], UploadField_UploadField.prototype, "value", void 0);

UploadField_decorate([Object(lit_element["f" /* property */])({
  type: Object
})], UploadField_UploadField.prototype, "messages", void 0);

UploadField_decorate([Object(lit_element["g" /* query */])("label")], UploadField_UploadField.prototype, "label", void 0);

UploadField_decorate([Object(lit_element["g" /* query */])("input")], UploadField_UploadField.prototype, "input", void 0);

Object(formsey_core["i" /* register */])("formsey-upload", UploadField_UploadField, "native", "upload", "@formsey/fields-native/UploadField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/URLField.ts


class URLField_URLField extends StringField_StringField {
  get type() {
    return "url";
  }

}
Object(formsey_core["i" /* register */])("formsey-url", URLField_URLField, "native", "url", "@formsey/fields-native/URLField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/WeekField.ts


class WeekField_WeekField extends DateField_DateField {
  get type() {
    return "week";
  }

}
Object(formsey_core["i" /* register */])("formsey-week", WeekField_WeekField, "native", "week", "@formsey/fields-native/WeekField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/YouTubeField.ts
var YouTubeField_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class YouTubeField_YouTubeField extends formsey_core["d" /* LabeledField */] {
  constructor() {
    super(...arguments);
    this.WATCH_PARAMETER = "watch?v=";
    this.YOUTU_PARAMETER = "youtu.be/";
  }

  renderField() {
    let width = this.definition.width;
    let style = "width:";

    if (width.endsWith("%")) {
      // Set absolute height
      let widthInPercent = width.substring(0, width.lastIndexOf("%"));
      let height = widthInPercent * 9 / 16;
      style += widthInPercent + "%;padding-bottom:" + height + "%";
    } else {
      if (width.endsWith("px")) {
        width = width.substring(0, width.lastIndexOf("px"));
      }

      let widthInPixel = width;
      let heightInPixel = widthInPixel * 9 / 16;
      style += widthInPixel + "px;height:" + heightInPixel + "px";
    }

    return lit_element["e" /* html */]`<div class="fs-video" style="${style};float:${this.definition.align}"><iframe src="//youtube.com/embed/${this.extractVideoId(this.definition.url)}"></iframe></div>`;
  }

  extractVideoId(videoUrl) {
    let videoId = videoUrl;
    let watchIndex = videoUrl.indexOf(this.WATCH_PARAMETER);

    if (watchIndex > 0) {
      videoId = videoUrl.substring(watchIndex + this.WATCH_PARAMETER.length);
    }

    let youtuIndex = videoUrl.indexOf(this.YOUTU_PARAMETER);

    if (youtuIndex > 0) {
      videoId = videoUrl.substring(youtuIndex + this.YOUTU_PARAMETER.length);
    }

    let paramsIndex = videoUrl.indexOf("&");

    if (paramsIndex > 0) {
      videoId = videoId.substring(0, paramsIndex);
    }

    paramsIndex = videoUrl.indexOf("?");

    if (paramsIndex > 0) {
      videoId = videoId.substring(0, paramsIndex);
    }

    return videoId;
  }

}

YouTubeField_decorate([Object(lit_element["f" /* property */])({
  converter: Object
})], YouTubeField_YouTubeField.prototype, "definition", void 0);

Object(formsey_core["i" /* register */])("formsey-youtube", YouTubeField_YouTubeField, "native", "youtube", "@formsey/fields-native/YouTubeField");
// CONCATENATED MODULE: ./packages/formsey-fields-native/basic.ts
































/***/ })
/******/ ]);